/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

namespace ChaniaBank {
export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/psd2";
    }

    /**
     * Get Consent Authorisation Sub-Resources Request
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getConsentAuthorisation(consentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<Authorisations> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}/authorisations";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentAuthorisation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentAuthorisation(<any>response_);
                } catch (e) {
                    return <Observable<Authorisations>><any>_observableThrow(e);
                }
            } else
                return <Observable<Authorisations>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsentAuthorisation(response: HttpResponseBase): Observable<Authorisations> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Authorisations.fromJS(resultData200) : new Authorisations();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Authorisations>(<any>null);
    }

    /**
     * Start the authorisation process for a consent
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param body (optional) 
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param tPPRedirectPreferred (optional) If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.
     * @param tPPRedirectURI (optional) URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.
     * @param tPPNokRedirectURI (optional) If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return Created
     */
    startConsentAuthorisation(xRequestID: string, consentId: string, body: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, tPPRedirectPreferred: string | null | undefined, tPPRedirectURI: string | null | undefined, tPPNokRedirectURI: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<StartScaprocessResponse> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}/authorisations";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "tPPRedirectPreferred": tPPRedirectPreferred !== undefined && tPPRedirectPreferred !== null ? "" + tPPRedirectPreferred : "", 
                "tPPRedirectURI": tPPRedirectURI !== undefined && tPPRedirectURI !== null ? "" + tPPRedirectURI : "", 
                "tPPNokRedirectURI": tPPNokRedirectURI !== undefined && tPPNokRedirectURI !== null ? "" + tPPNokRedirectURI : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartConsentAuthorisation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartConsentAuthorisation(<any>response_);
                } catch (e) {
                    return <Observable<StartScaprocessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<StartScaprocessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartConsentAuthorisation(response: HttpResponseBase): Observable<StartScaprocessResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? StartScaprocessResponse.fromJS(resultData201) : new StartScaprocessResponse();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StartScaprocessResponse>(<any>null);
    }

    /**
     * Get Consent Request
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getConsentInformation(consentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<ConsentInformationResponse200Json> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentInformation(<any>response_);
                } catch (e) {
                    return <Observable<ConsentInformationResponse200Json>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsentInformationResponse200Json>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsentInformation(response: HttpResponseBase): Observable<ConsentInformationResponse200Json> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConsentInformationResponse200Json.fromJS(resultData200) : new ConsentInformationResponse200Json();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsentInformationResponse200Json>(<any>null);
    }

    /**
     * Read the SCA status of the consent authorisation.
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param authorisationId Resource identification of the related SCA.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getConsentScaStatus(consentId: string, authorisationId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<ScaStatusResponse> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}/authorisations/{authorisationId}";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        if (authorisationId === undefined || authorisationId === null)
            throw new Error("The parameter 'authorisationId' must be defined.");
        url_ = url_.replace("{authorisationId}", encodeURIComponent("" + authorisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentScaStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentScaStatus(<any>response_);
                } catch (e) {
                    return <Observable<ScaStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScaStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsentScaStatus(response: HttpResponseBase): Observable<ScaStatusResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaStatusResponse.fromJS(resultData200) : new ScaStatusResponse();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScaStatusResponse>(<any>null);
    }

    /**
     * Update PSU Data for consents
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param authorisationId Resource identification of the related SCA.
     * @param body (optional) 
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    updateConsentsPsuData(xRequestID: string, consentId: string, authorisationId: string, body: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}/authorisations/{authorisationId}";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        if (authorisationId === undefined || authorisationId === null)
            throw new Error("The parameter 'authorisationId' must be defined.");
        url_ = url_.replace("{authorisationId}", encodeURIComponent("" + authorisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsentsPsuData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsentsPsuData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConsentsPsuData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Consent status request
     * @param consentId ID of the corresponding consent object as returned by an Account Information Consent Request.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getConsentStatus(consentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<ConsentStatusResponse200> {
        let url_ = this.baseUrl + "/v1/consents/{consentId}/status";
        if (consentId === undefined || consentId === null)
            throw new Error("The parameter 'consentId' must be defined.");
        url_ = url_.replace("{consentId}", encodeURIComponent("" + consentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentStatus(<any>response_);
                } catch (e) {
                    return <Observable<ConsentStatusResponse200>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsentStatusResponse200>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsentStatus(response: HttpResponseBase): Observable<ConsentStatusResponse200> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConsentStatusResponse200.fromJS(resultData200) : new ConsentStatusResponse200();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsentStatusResponse200>(<any>null);
    }

    /**
     * Read Transaction Details
     * @param accountId This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.
     * @param resourceId This identification is given by the attribute resourceId of the corresponding entry of a transaction list.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getTransactionDetails(accountId: string, resourceId: string, xRequestID: string, consentId: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<TransactionDetails> {
        let url_ = this.baseUrl + "/v1/accounts/{accountId}/transactions/{resourceId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "consentId": consentId !== undefined && consentId !== null ? "" + consentId : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(<any>response_);
                } catch (e) {
                    return <Observable<TransactionDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionDetails>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<TransactionDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionDetails.fromJS(resultData200) : new TransactionDetails();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionDetails>(<any>null);
    }

    /**
     * Read transaction list of an account
     * @param accountId This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.
     * @param bookingStatus Permitted codes are    * \"booked\",   * \"pending\" and    * \"both\" \"booked\" shall be supported by the ASPSP. To support the \"pending\" and \"both\" feature is optional for the ASPSP,  Error code if not supported in the online banking frontend
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.
     * @param dateFrom (optional) Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.
     * @param dateTo (optional) End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.
     * @param entryReferenceFrom (optional) This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \"dateFrom\" and \"dateTo\" might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider.
     * @param deltaList (optional) This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider
     * @param withBalance (optional) If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getTransactionList(accountId: string, bookingStatus: string, xRequestID: string, consentId: string, dateFrom: Date | null | undefined, dateTo: Date | null | undefined, entryReferenceFrom: string | null | undefined, deltaList: boolean | null | undefined, withBalance: boolean | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<TransactionsResponse200Json> {
        let url_ = this.baseUrl + "/v1/accounts/{accountId}/transactions?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        if (bookingStatus === undefined || bookingStatus === null)
            throw new Error("The parameter 'bookingStatus' must be defined and cannot be null.");
        else
            url_ += "bookingStatus=" + encodeURIComponent("" + bookingStatus) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        if (entryReferenceFrom !== undefined)
            url_ += "entryReferenceFrom=" + encodeURIComponent("" + entryReferenceFrom) + "&"; 
        if (deltaList !== undefined)
            url_ += "deltaList=" + encodeURIComponent("" + deltaList) + "&"; 
        if (withBalance !== undefined)
            url_ += "withBalance=" + encodeURIComponent("" + withBalance) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "consentId": consentId !== undefined && consentId !== null ? "" + consentId : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionList(<any>response_);
                } catch (e) {
                    return <Observable<TransactionsResponse200Json>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionsResponse200Json>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionList(response: HttpResponseBase): Observable<TransactionsResponse200Json> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionsResponse200Json.fromJS(resultData200) : new TransactionsResponse200Json();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionsResponse200Json>(<any>null);
    }

    /**
     * Read Account Details
     * @param accountId This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.
     * @param withBalance (optional) If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    readAccountDetails(accountId: string, xRequestID: string, consentId: string, withBalance: boolean | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<AccountDetails> {
        let url_ = this.baseUrl + "/v1/accounts/{accountId}?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        if (withBalance !== undefined)
            url_ += "withBalance=" + encodeURIComponent("" + withBalance) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "consentId": consentId !== undefined && consentId !== null ? "" + consentId : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAccountDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAccountDetails(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetails>><any>_observableThrow(response_);
        }));
    }

    protected processReadAccountDetails(response: HttpResponseBase): Observable<AccountDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountDetails.fromJS(resultData200) : new AccountDetails();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetails>(<any>null);
    }

    /**
     * Confirmation of Funds Request
     * @param body (optional) Request body for a confirmation of funds request.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param consentId (optional) This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @return OK
     */
    checkAvailabilityOfFunds(body: ConfirmationOfFunds | null | undefined, xRequestID: string, consentId: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined): Observable<ConfirmationOfFundsResponse200> {
        let url_ = this.baseUrl + "/v1/funds-confirmations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "consentId": consentId !== undefined && consentId !== null ? "" + consentId : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAvailabilityOfFunds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAvailabilityOfFunds(<any>response_);
                } catch (e) {
                    return <Observable<ConfirmationOfFundsResponse200>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConfirmationOfFundsResponse200>><any>_observableThrow(response_);
        }));
    }

    protected processCheckAvailabilityOfFunds(response: HttpResponseBase): Observable<ConfirmationOfFundsResponse200> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConfirmationOfFundsResponse200.fromJS(resultData200) : new ConfirmationOfFundsResponse200();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIIS.fromJS(resultData401) : new Error401NGPIIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIIS.fromJS(resultData403) : new Error403NGPIIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIIS.fromJS(resultData404) : new Error404NGPIIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIIS.fromJS(resultData405) : new Error405NGPIIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIIS.fromJS(resultData409) : new Error409NGPIIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfirmationOfFundsResponse200>(<any>null);
    }

    /**
     * Get Branches information
     * @param if_Modified_Since (optional) Used for conditional request, to retrieve data only if modified since a given date
     * @param if_None_Match (optional) Used for conditional request, to retrieve data only if the given Etag value does not match
     * @return OK
     */
    getBranches(if_Modified_Since: string | null | undefined, if_None_Match: string | null | undefined): Observable<Branch[]> {
        let url_ = this.baseUrl + "/v1/opendata/branches?";
        if (if_Modified_Since !== undefined)
            url_ += "if_Modified_Since=" + encodeURIComponent("" + if_Modified_Since) + "&"; 
        if (if_None_Match !== undefined)
            url_ += "if_None_Match=" + encodeURIComponent("" + if_None_Match) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranches(<any>response_);
                } catch (e) {
                    return <Observable<Branch[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Branch[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranches(response: HttpResponseBase): Observable<Branch[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Branch.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Branch[]>(<any>null);
    }

    /**
     * Successful response with a list of `ATM` data
     * @param if_Modified_Since (optional) Used for conditional request, to retrieve data only if modified since a given date
     * @param if_None_Match (optional) Used for conditional request, to retrieve data only if the given Etag value does not match
     * @return OK
     */
    getATMs(if_Modified_Since: string | null | undefined, if_None_Match: string | null | undefined): Observable<ATM[]> {
        let url_ = this.baseUrl + "/v1/opendata/atm?";
        if (if_Modified_Since !== undefined)
            url_ += "if_Modified_Since=" + encodeURIComponent("" + if_Modified_Since) + "&"; 
        if (if_None_Match !== undefined)
            url_ += "if_None_Match=" + encodeURIComponent("" + if_None_Match) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetATMs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetATMs(<any>response_);
                } catch (e) {
                    return <Observable<ATM[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ATM[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetATMs(response: HttpResponseBase): Observable<ATM[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ATM.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGAIS.fromJS(resultData400) : new Error400NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGAIS.fromJS(resultData401) : new Error401NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGAIS.fromJS(resultData403) : new Error403NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGAIS.fromJS(resultData404) : new Error404NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGAIS.fromJS(resultData405) : new Error405NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 ? Error406NGAIS.fromJS(resultData406) : new Error406NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGAIS.fromJS(resultData409) : new Error409NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = resultData429 ? Error429NGAIS.fromJS(resultData429) : new Error429NGAIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ATM[]>(<any>null);
    }

    /**
     * Get Payment Information
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentInformation(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInformation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInformation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Payment Cancellation Request
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return Received
     */
    cancelPayment(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<PaymentInitiationCancelResponse202> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInitiationCancelResponse202>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInitiationCancelResponse202>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<PaymentInitiationCancelResponse202> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = resultData202 ? PaymentInitiationCancelResponse202.fromJS(resultData202) : new PaymentInitiationCancelResponse202();
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPISCANC.fromJS(resultData405) : new Error405NGPISCANC();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInitiationCancelResponse202>(<any>null);
    }

    /**
     * Read the SCA status of the payment cancellation's authorisation.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param cancellationId Identification for cancellation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentCancellationScaStatus(paymentService: string, paymentProduct: string, paymentId: string, cancellationId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<ScaStatusResponse> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations/{cancellationId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        if (cancellationId === undefined || cancellationId === null)
            throw new Error("The parameter 'cancellationId' must be defined.");
        url_ = url_.replace("{cancellationId}", encodeURIComponent("" + cancellationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentCancellationScaStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentCancellationScaStatus(<any>response_);
                } catch (e) {
                    return <Observable<ScaStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScaStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentCancellationScaStatus(response: HttpResponseBase): Observable<ScaStatusResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaStatusResponse.fromJS(resultData200) : new ScaStatusResponse();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScaStatusResponse>(<any>null);
    }

    /**
     * Update PSU Data for payment initiation cancellation
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param cancellationId Identification for cancellation resource.
     * @param body (optional) 
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    updatePaymentCancellationPsuData(xRequestID: string, paymentService: string, paymentProduct: string, paymentId: string, cancellationId: string, body: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations/{cancellationId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        if (cancellationId === undefined || cancellationId === null)
            throw new Error("The parameter 'cancellationId' must be defined.");
        url_ = url_.replace("{cancellationId}", encodeURIComponent("" + cancellationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaymentCancellationPsuData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaymentCancellationPsuData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePaymentCancellationPsuData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get Payment Initiation Authorisation Sub-Resources Request
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentInitiationAuthorisation(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<Authorisations> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInitiationAuthorisation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInitiationAuthorisation(<any>response_);
                } catch (e) {
                    return <Observable<Authorisations>><any>_observableThrow(e);
                }
            } else
                return <Observable<Authorisations>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInitiationAuthorisation(response: HttpResponseBase): Observable<Authorisations> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Authorisations.fromJS(resultData200) : new Authorisations();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Authorisations>(<any>null);
    }

    /**
     * Start the authorisation process for a payment initiation
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param body (optional) 
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param tPPRedirectPreferred (optional) If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.
     * @param tPPRedirectURI (optional) URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.
     * @param tPPNokRedirectURI (optional) If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return Created
     */
    startPaymentAuthorisation(xRequestID: string, paymentService: string, paymentProduct: string, paymentId: string, body: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, tPPRedirectPreferred: string | null | undefined, tPPRedirectURI: string | null | undefined, tPPNokRedirectURI: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<StartScaprocessResponse> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "tPPRedirectPreferred": tPPRedirectPreferred !== undefined && tPPRedirectPreferred !== null ? "" + tPPRedirectPreferred : "", 
                "tPPRedirectURI": tPPRedirectURI !== undefined && tPPRedirectURI !== null ? "" + tPPRedirectURI : "", 
                "tPPNokRedirectURI": tPPNokRedirectURI !== undefined && tPPNokRedirectURI !== null ? "" + tPPNokRedirectURI : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartPaymentAuthorisation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartPaymentAuthorisation(<any>response_);
                } catch (e) {
                    return <Observable<StartScaprocessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<StartScaprocessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartPaymentAuthorisation(response: HttpResponseBase): Observable<StartScaprocessResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? StartScaprocessResponse.fromJS(resultData201) : new StartScaprocessResponse();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StartScaprocessResponse>(<any>null);
    }

    /**
     * Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentInitiationCancellationAuthorisationInformation(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInitiationCancellationAuthorisationInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInitiationCancellationAuthorisationInformation(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInitiationCancellationAuthorisationInformation(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * Start the authorisation process for the cancellation of the addressed payment
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param tPPRedirectPreferred (optional) If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.
     * @param tPPRedirectURI (optional) URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.
     * @param tPPNokRedirectURI (optional) If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return Created
     */
    startPaymentInitiationCancellationAuthorisation(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, tPPRedirectPreferred: string | null | undefined, tPPRedirectURI: string | null | undefined, tPPNokRedirectURI: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<StartScaprocessResponse> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "tPPRedirectPreferred": tPPRedirectPreferred !== undefined && tPPRedirectPreferred !== null ? "" + tPPRedirectPreferred : "", 
                "tPPRedirectURI": tPPRedirectURI !== undefined && tPPRedirectURI !== null ? "" + tPPRedirectURI : "", 
                "tPPNokRedirectURI": tPPNokRedirectURI !== undefined && tPPNokRedirectURI !== null ? "" + tPPNokRedirectURI : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartPaymentInitiationCancellationAuthorisation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartPaymentInitiationCancellationAuthorisation(<any>response_);
                } catch (e) {
                    return <Observable<StartScaprocessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<StartScaprocessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartPaymentInitiationCancellationAuthorisation(response: HttpResponseBase): Observable<StartScaprocessResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? StartScaprocessResponse.fromJS(resultData201) : new StartScaprocessResponse();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StartScaprocessResponse>(<any>null);
    }

    /**
     * Read the SCA Status of the payment authorisation
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param authorisationId Resource identification of the related SCA.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentInitiationScaStatus(paymentService: string, paymentProduct: string, paymentId: string, authorisationId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<ScaStatusResponse> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations/{authorisationId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        if (authorisationId === undefined || authorisationId === null)
            throw new Error("The parameter 'authorisationId' must be defined.");
        url_ = url_.replace("{authorisationId}", encodeURIComponent("" + authorisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInitiationScaStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInitiationScaStatus(<any>response_);
                } catch (e) {
                    return <Observable<ScaStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScaStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInitiationScaStatus(response: HttpResponseBase): Observable<ScaStatusResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaStatusResponse.fromJS(resultData200) : new ScaStatusResponse();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScaStatusResponse>(<any>null);
    }

    /**
     * Update PSU data for payment initiation
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param authorisationId Resource identification of the related SCA.
     * @param body (optional) 
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    updatePaymentPsuData(xRequestID: string, paymentService: string, paymentProduct: string, paymentId: string, authorisationId: string, body: string | null | undefined, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations/{authorisationId}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        if (authorisationId === undefined || authorisationId === null)
            throw new Error("The parameter 'authorisationId' must be defined.");
        url_ = url_.replace("{authorisationId}", encodeURIComponent("" + authorisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaymentPsuData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaymentPsuData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePaymentPsuData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Payment initiation status request
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param paymentId Resource identification of the generated payment initiation resource.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSUIPAddress (optional) The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return OK
     */
    getPaymentInitiationStatus(paymentService: string, paymentProduct: string, paymentId: string, xRequestID: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSUIPAddress: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<PaymentInitiationStatusResponse200Json> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}/{paymentId}/status";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInitiationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInitiationStatus(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInitiationStatusResponse200Json>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInitiationStatusResponse200Json>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInitiationStatus(response: HttpResponseBase): Observable<PaymentInitiationStatusResponse200Json> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInitiationStatusResponse200Json.fromJS(resultData200) : new PaymentInitiationStatusResponse200Json();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInitiationStatusResponse200Json>(<any>null);
    }

    /**
     * Payment initiation request
     * @param body (optional) JSON request body for a payment inition request message 
                There are the following paymentProducts supported:
                * "sepa-credit-transfers" with JSON-Body
                * "instant-sepa-credit-transfers" with JSON-Body
                * "target-2-payments" with JSON-Body
                * "cross-border-credit-transfers" with JSON-Body
                * "pain.001-sepa-credit-transfers" with XML pain.001.001.03 body for SCT scheme
                * "pain.001-instant-sepa-credit-transfers" with XML pain.001.001.03 body for SCT INST scheme
                * "pain.001-target-2-payments" with pain.001 body. 
                Only country specific schemes are currently available
                * "pain.001-cross-border-credit-transfers" with pain.001 body. 
                Only country specific schemes are currently available
                There are the following paymentServices supported:
                * "payments"
                * "periodic-payments"
                * "bulk-paments"
                All optional, conditional and predefined but not yet used fields are defined.
     * @param xRequestID ID of the request, unique to the call, as determined by the initiating party.
     * @param pSUIPAddress The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
     * @param paymentService Payment service:  Possible values are: * payments * bulk-payments * periodic-payments
     * @param paymentProduct The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.
     * @param digest (optional) Is contained if and only if the \"Signature\" element is contained in the header of the request.
     * @param signature (optional) A signature of the request by the TPP on application level. This might be mandated by ASPSP.
     * @param tPPSignatureCertificate (optional) The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.
     * @param pSU_ID (optional) Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.
     * @param pSUIDType (optional) Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.
     * @param pSUCorporateID (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param pSUCorporateIDType (optional) Might be mandated in the ASPSP's documentation. Only used in a corporate context.
     * @param consentId (optional) This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.
     * @param tPPRedirectPreferred (optional) If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.
     * @param tPPRedirectURI (optional) URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.
     * @param tPPNokRedirectURI (optional) If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.
     * @param tPPExplicitAuthorisationPreferred (optional) If it equals \"true\", the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \"false\" or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket.
     * @param tPPRejectionNoFundsPreferred (optional) If it equals \"true\" then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \"false\" then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP.
     * @param pSUIPPort (optional) The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
     * @param pSUAccept (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptCharset (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptEncoding (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUAcceptLanguage (optional) The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
     * @param pSUUserAgent (optional) The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
     * @param pSUHttpMethod (optional) HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE
     * @param pSUDeviceID (optional) UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
     * @param pSUGeoLocation (optional) The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
     * @return CREATED
     */
    initiatePayment(body: string | null | undefined, xRequestID: string, pSUIPAddress: string, paymentService: string, paymentProduct: string, digest: string | null | undefined, signature: string | null | undefined, tPPSignatureCertificate: string | null | undefined, pSU_ID: string | null | undefined, pSUIDType: string | null | undefined, pSUCorporateID: string | null | undefined, pSUCorporateIDType: string | null | undefined, consentId: string | null | undefined, tPPRedirectPreferred: string | null | undefined, tPPRedirectURI: string | null | undefined, tPPNokRedirectURI: string | null | undefined, tPPExplicitAuthorisationPreferred: string | null | undefined, tPPRejectionNoFundsPreferred: string | null | undefined, pSUIPPort: string | null | undefined, pSUAccept: string | null | undefined, pSUAcceptCharset: string | null | undefined, pSUAcceptEncoding: string | null | undefined, pSUAcceptLanguage: string | null | undefined, pSUUserAgent: string | null | undefined, pSUHttpMethod: string | null | undefined, pSUDeviceID: string | null | undefined, pSUGeoLocation: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/{paymentService}/{paymentProduct}";
        if (paymentService === undefined || paymentService === null)
            throw new Error("The parameter 'paymentService' must be defined.");
        url_ = url_.replace("{paymentService}", encodeURIComponent("" + paymentService)); 
        if (paymentProduct === undefined || paymentProduct === null)
            throw new Error("The parameter 'paymentProduct' must be defined.");
        url_ = url_.replace("{paymentProduct}", encodeURIComponent("" + paymentProduct)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "xRequestID": xRequestID !== undefined && xRequestID !== null ? "" + xRequestID : "", 
                "pSUIPAddress": pSUIPAddress !== undefined && pSUIPAddress !== null ? "" + pSUIPAddress : "", 
                "digest": digest !== undefined && digest !== null ? "" + digest : "", 
                "signature": signature !== undefined && signature !== null ? "" + signature : "", 
                "tPPSignatureCertificate": tPPSignatureCertificate !== undefined && tPPSignatureCertificate !== null ? "" + tPPSignatureCertificate : "", 
                "PSU_ID": pSU_ID !== undefined && pSU_ID !== null ? "" + pSU_ID : "", 
                "pSUIDType": pSUIDType !== undefined && pSUIDType !== null ? "" + pSUIDType : "", 
                "pSUCorporateID": pSUCorporateID !== undefined && pSUCorporateID !== null ? "" + pSUCorporateID : "", 
                "pSUCorporateIDType": pSUCorporateIDType !== undefined && pSUCorporateIDType !== null ? "" + pSUCorporateIDType : "", 
                "consentId": consentId !== undefined && consentId !== null ? "" + consentId : "", 
                "tPPRedirectPreferred": tPPRedirectPreferred !== undefined && tPPRedirectPreferred !== null ? "" + tPPRedirectPreferred : "", 
                "tPPRedirectURI": tPPRedirectURI !== undefined && tPPRedirectURI !== null ? "" + tPPRedirectURI : "", 
                "tPPNokRedirectURI": tPPNokRedirectURI !== undefined && tPPNokRedirectURI !== null ? "" + tPPNokRedirectURI : "", 
                "tPPExplicitAuthorisationPreferred": tPPExplicitAuthorisationPreferred !== undefined && tPPExplicitAuthorisationPreferred !== null ? "" + tPPExplicitAuthorisationPreferred : "", 
                "tPPRejectionNoFundsPreferred": tPPRejectionNoFundsPreferred !== undefined && tPPRejectionNoFundsPreferred !== null ? "" + tPPRejectionNoFundsPreferred : "", 
                "pSUIPPort": pSUIPPort !== undefined && pSUIPPort !== null ? "" + pSUIPPort : "", 
                "pSUAccept": pSUAccept !== undefined && pSUAccept !== null ? "" + pSUAccept : "", 
                "pSUAcceptCharset": pSUAcceptCharset !== undefined && pSUAcceptCharset !== null ? "" + pSUAcceptCharset : "", 
                "pSUAcceptEncoding": pSUAcceptEncoding !== undefined && pSUAcceptEncoding !== null ? "" + pSUAcceptEncoding : "", 
                "pSUAcceptLanguage": pSUAcceptLanguage !== undefined && pSUAcceptLanguage !== null ? "" + pSUAcceptLanguage : "", 
                "pSUUserAgent": pSUUserAgent !== undefined && pSUUserAgent !== null ? "" + pSUUserAgent : "", 
                "pSUHttpMethod": pSUHttpMethod !== undefined && pSUHttpMethod !== null ? "" + pSUHttpMethod : "", 
                "pSUDeviceID": pSUDeviceID !== undefined && pSUDeviceID !== null ? "" + pSUDeviceID : "", 
                "pSUGeoLocation": pSUGeoLocation !== undefined && pSUGeoLocation !== null ? "" + pSUGeoLocation : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitiatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitiatePayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInitiatePayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? Error400NGPIS.fromJS(resultData400) : new Error400NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 ? Error401NGPIS.fromJS(resultData401) : new Error401NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? Error403NGPIS.fromJS(resultData403) : new Error403NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? Error404NGPIS.fromJS(resultData404) : new Error404NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Error405NGPIS.fromJS(resultData405) : new Error405NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? Error409NGPIS.fromJS(resultData409) : new Error409NGPIS();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 408) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

/** An array of all authorisationIds */
export class Authorisations implements IAuthorisations {
    /** Gets or Sets AuthorisationIds - An array of all authorisationIds */
    authorisationIds!: string[];

    constructor(data?: IAuthorisations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authorisationIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["authorisationIds"] && data["authorisationIds"].constructor === Array) {
                this.authorisationIds = [] as any;
                for (let item of data["authorisationIds"])
                    this.authorisationIds!.push(item);
            }
        }
    }

    static fromJS(data: any): Authorisations {
        data = typeof data === 'object' ? data : {};
        let result = new Authorisations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.authorisationIds && this.authorisationIds.constructor === Array) {
            data["authorisationIds"] = [];
            for (let item of this.authorisationIds)
                data["authorisationIds"].push(item);
        }
        return data; 
    }
}

/** An array of all authorisationIds */
export interface IAuthorisations {
    /** Gets or Sets AuthorisationIds - An array of all authorisationIds */
    authorisationIds: string[];
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400. */
export class Error400NGAIS implements IError400NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage400AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError400NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage400AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error400NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error400NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400. */
export interface IError400NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage400AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage400AIS implements ITppMessage400AIS {
    /** Gets or Sets Category */
    category!: TppMessage400AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage400AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage400AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage400AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage400AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage400AIS {
    /** Gets or Sets Category */
    category: TppMessage400AISCategory;
    /** Gets or Sets Code */
    code: TppMessage400AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** Link to a resource */
export class HrefType implements IHrefType {
    /** Gets or Sets Href - Link to a resource */
    href?: string | undefined;

    constructor(data?: IHrefType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): HrefType {
        data = typeof data === 'object' ? data : {};
        let result = new HrefType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

/** Link to a resource */
export interface IHrefType {
    /** Gets or Sets Href - Link to a resource */
    href?: string | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error401NGAIS implements IError401NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError401NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage401AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error401NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error401NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError401NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage401AIS implements ITppMessage401AIS {
    /** Gets or Sets Category */
    category!: TppMessage401AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage401AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage401AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage401AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage401AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage401AIS {
    /** Gets or Sets Category */
    category: TppMessage401AISCategory;
    /** Gets or Sets Code */
    code: TppMessage401AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export class Error403NGAIS implements IError403NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError403NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage403AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error403NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error403NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export interface IError403NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage403AIS implements ITppMessage403AIS {
    /** Gets or Sets Category */
    category!: TppMessage403AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage403AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage403AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage403AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage403AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage403AIS {
    /** Gets or Sets Category */
    category: TppMessage403AISCategory;
    /** Gets or Sets Code */
    code: TppMessage403AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export class Error404NGAIS implements IError404NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError404NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage404AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error404NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error404NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export interface IError404NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage404AIS implements ITppMessage404AIS {
    /** Gets or Sets Category */
    category!: TppMessage404AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage404AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage404AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage404AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage404AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage404AIS {
    /** Gets or Sets Category */
    category: TppMessage404AISCategory;
    /** Gets or Sets Code */
    code: TppMessage404AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error405NGAIS implements IError405NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError405NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage405AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error405NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error405NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError405NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage405AIS implements ITppMessage405AIS {
    /** Gets or Sets Category */
    category!: TppMessage405AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage405AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage405AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage405AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage405AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage405AIS {
    /** Gets or Sets Category */
    category: TppMessage405AISCategory;
    /** Gets or Sets Code */
    code: TppMessage405AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 406. */
export class Error406NGAIS implements IError406NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage406AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError406NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage406AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error406NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error406NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 406. */
export interface IError406NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage406AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage406AIS implements ITppMessage406AIS {
    /** Gets or Sets Category */
    category!: TppMessage406AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage406AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage406AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage406AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage406AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage406AIS {
    /** Gets or Sets Category */
    category: TppMessage406AISCategory;
    /** Gets or Sets Code */
    code: TppMessage406AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export class Error409NGAIS implements IError409NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError409NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage409AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error409NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error409NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export interface IError409NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage409AIS implements ITppMessage409AIS {
    /** Gets or Sets Category */
    category!: TppMessage409AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage409AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage409AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage409AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage409AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage409AIS {
    /** Gets or Sets Category */
    category: TppMessage409AISCategory;
    /** Gets or Sets Code */
    code: TppMessage409AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 429. */
export class Error429NGAIS implements IError429NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage429AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError429NGAIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage429AIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error429NGAIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error429NGAIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 429. */
export interface IError429NGAIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage429AIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage429AIS implements ITppMessage429AIS {
    /** Gets or Sets Category */
    category!: TppMessage429AISCategory;
    /** Gets or Sets Code */
    code!: TppMessage429AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage429AIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage429AIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage429AIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage429AIS {
    /** Gets or Sets Category */
    category: TppMessage429AISCategory;
    /** Gets or Sets Code */
    code: TppMessage429AISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** Body of the JSON response for a Start SCA authorisation request. */
export class StartScaprocessResponse implements IStartScaprocessResponse {
    /** Gets or Sets ScaStatus */
    scaStatus!: StartScaprocessResponseScaStatus;
    /** Gets or Sets AuthorisationId */
    authorisationId!: string;
    /** Gets or Sets ScaMethods */
    scaMethods?: AuthenticationObject[] | undefined;
    /** Gets or Sets ChosenScaMethod */
    chosenScaMethod?: any | undefined;
    /** Gets or Sets ChallengeData */
    challengeData?: ChallengeData | undefined;
    /** Gets or Sets Links */
    _links!: { [key: string] : HrefType; };
    /** Gets or Sets PsuMessage - Text to be displayed to the PSU */
    psuMessage?: string | undefined;

    constructor(data?: IStartScaprocessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this._links = {};
        }
    }

    init(data?: any) {
        if (data) {
            this.scaStatus = data["scaStatus"];
            this.authorisationId = data["authorisationId"];
            if (data["scaMethods"] && data["scaMethods"].constructor === Array) {
                this.scaMethods = [] as any;
                for (let item of data["scaMethods"])
                    this.scaMethods!.push(AuthenticationObject.fromJS(item));
            }
            this.chosenScaMethod = data["chosenScaMethod"];
            this.challengeData = data["challengeData"] ? ChallengeData.fromJS(data["challengeData"]) : <any>undefined;
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
            this.psuMessage = data["psuMessage"];
        }
    }

    static fromJS(data: any): StartScaprocessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StartScaprocessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scaStatus"] = this.scaStatus;
        data["authorisationId"] = this.authorisationId;
        if (this.scaMethods && this.scaMethods.constructor === Array) {
            data["scaMethods"] = [];
            for (let item of this.scaMethods)
                data["scaMethods"].push(item.toJSON());
        }
        data["chosenScaMethod"] = this.chosenScaMethod;
        data["challengeData"] = this.challengeData ? this.challengeData.toJSON() : <any>undefined;
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        data["psuMessage"] = this.psuMessage;
        return data; 
    }
}

/** Body of the JSON response for a Start SCA authorisation request. */
export interface IStartScaprocessResponse {
    /** Gets or Sets ScaStatus */
    scaStatus: StartScaprocessResponseScaStatus;
    /** Gets or Sets AuthorisationId */
    authorisationId: string;
    /** Gets or Sets ScaMethods */
    scaMethods?: AuthenticationObject[] | undefined;
    /** Gets or Sets ChosenScaMethod */
    chosenScaMethod?: any | undefined;
    /** Gets or Sets ChallengeData */
    challengeData?: ChallengeData | undefined;
    /** Gets or Sets Links */
    _links: { [key: string] : HrefType; };
    /** Gets or Sets PsuMessage - Text to be displayed to the PSU */
    psuMessage?: string | undefined;
}

/** Authentication Object */
export class AuthenticationObject implements IAuthenticationObject {
    /** Gets or Sets AuthenticationType */
    authenticationType!: AuthenticationObjectAuthenticationType;
    /** Depending on the \"authenticationType\". This version can be used by differentiating authentication tools used within performing OTP generation in the same authentication type. This version can be referred to in the ASPSP?s documentation. */
    authenticationVersion?: string | undefined;
    /** Gets or Sets AuthenticationMethodId - An identification provided by the ASPSP for the later identification of the authentication method selection. */
    authenticationMethodId!: string;
    /** This is the name of the authentication method defined by the PSU in the Online Banking frontend of the ASPSP. Alternatively this could be a description provided by the ASPSP like \"SMS OTP on phone +49160 xxxxx 28\". This name shall be used by the TPP when presenting a list of authentication methods to the PSU, if available. */
    name?: string | undefined;
    /** Detailed information about the SCA method for the PSU. */
    explanation?: string | undefined;

    constructor(data?: IAuthenticationObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticationType = data["authenticationType"];
            this.authenticationVersion = data["authenticationVersion"];
            this.authenticationMethodId = data["authenticationMethodId"];
            this.name = data["name"];
            this.explanation = data["explanation"];
        }
    }

    static fromJS(data: any): AuthenticationObject {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["authenticationVersion"] = this.authenticationVersion;
        data["authenticationMethodId"] = this.authenticationMethodId;
        data["name"] = this.name;
        data["explanation"] = this.explanation;
        return data; 
    }
}

/** Authentication Object */
export interface IAuthenticationObject {
    /** Gets or Sets AuthenticationType */
    authenticationType: AuthenticationObjectAuthenticationType;
    /** Depending on the \"authenticationType\". This version can be used by differentiating authentication tools used within performing OTP generation in the same authentication type. This version can be referred to in the ASPSP?s documentation. */
    authenticationVersion?: string | undefined;
    /** Gets or Sets AuthenticationMethodId - An identification provided by the ASPSP for the later identification of the authentication method selection. */
    authenticationMethodId: string;
    /** This is the name of the authentication method defined by the PSU in the Online Banking frontend of the ASPSP. Alternatively this could be a description provided by the ASPSP like \"SMS OTP on phone +49160 xxxxx 28\". This name shall be used by the TPP when presenting a list of authentication methods to the PSU, if available. */
    name?: string | undefined;
    /** Detailed information about the SCA method for the PSU. */
    explanation?: string | undefined;
}

/** It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA. In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link. */
export class ChallengeData implements IChallengeData {
    /** PNG data (max. 512 kilobyte) to be displayed to the PSU, Base64 encoding, cp. [RFC4648]. This attribute is used only, when PHOTO_OTP or CHIP_OTP is the selected SCA method. */
    image?: string | undefined;
    /** String challenge data */
    data?: string | undefined;
    /** A link where the ASPSP will provides the challenge image for the TPP. */
    imageLink?: string | undefined;
    /** The maximal length for the OTP to be typed in by the PSU. */
    otpMaxLength?: number | undefined;
    /** The format type of the OTP to be typed in. The admitted values are \"characters\" or \"integer\". */
    otpFormat?: ChallengeDataOtpFormat | undefined;
    /** Additional explanation for the PSU to explain e.g. fallback mechanism for the chosen SCA method. The TPP is obliged to show this to the PSU. */
    additionalInformation?: string | undefined;

    constructor(data?: IChallengeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.image = data["image"];
            this.data = data["data"];
            this.imageLink = data["imageLink"];
            this.otpMaxLength = data["otpMaxLength"];
            this.otpFormat = data["otpFormat"];
            this.additionalInformation = data["additionalInformation"];
        }
    }

    static fromJS(data: any): ChallengeData {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["data"] = this.data;
        data["imageLink"] = this.imageLink;
        data["otpMaxLength"] = this.otpMaxLength;
        data["otpFormat"] = this.otpFormat;
        data["additionalInformation"] = this.additionalInformation;
        return data; 
    }
}

/** It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA. In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link. */
export interface IChallengeData {
    /** PNG data (max. 512 kilobyte) to be displayed to the PSU, Base64 encoding, cp. [RFC4648]. This attribute is used only, when PHOTO_OTP or CHIP_OTP is the selected SCA method. */
    image?: string | undefined;
    /** String challenge data */
    data?: string | undefined;
    /** A link where the ASPSP will provides the challenge image for the TPP. */
    imageLink?: string | undefined;
    /** The maximal length for the OTP to be typed in by the PSU. */
    otpMaxLength?: number | undefined;
    /** The format type of the OTP to be typed in. The admitted values are \"characters\" or \"integer\". */
    otpFormat?: ChallengeDataOtpFormat | undefined;
    /** Additional explanation for the PSU to explain e.g. fallback mechanism for the chosen SCA method. The TPP is obliged to show this to the PSU. */
    additionalInformation?: string | undefined;
}

/** Body of the JSON response for a successfull get consent request. */
export class ConsentInformationResponse200Json implements IConsentInformationResponse200Json {
    /** Gets or Sets Access */
    access!: AccountAccess;
    /** Gets or Sets RecurringIndicator */
    recurringIndicator!: any;
    /** Gets or Sets ValidUntil */
    validUntil!: Date;
    /** Gets or Sets FrequencyPerDay - This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one. */
    frequencyPerDay!: number;
    /** Gets or Sets LastActionDate */
    lastActionDate!: Date;
    /** Gets or Sets ConsentStatus */
    consentStatus!: ConsentInformationResponse200JsonConsentStatus;

    constructor(data?: IConsentInformationResponse200Json) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.access = new AccountAccess();
        }
    }

    init(data?: any) {
        if (data) {
            this.access = data["access"] ? AccountAccess.fromJS(data["access"]) : new AccountAccess();
            this.recurringIndicator = data["recurringIndicator"];
            this.validUntil = data["validUntil"] ? new Date(data["validUntil"].toString()) : <any>undefined;
            this.frequencyPerDay = data["frequencyPerDay"];
            this.lastActionDate = data["lastActionDate"] ? new Date(data["lastActionDate"].toString()) : <any>undefined;
            this.consentStatus = data["consentStatus"];
        }
    }

    static fromJS(data: any): ConsentInformationResponse200Json {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentInformationResponse200Json();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access"] = this.access ? this.access.toJSON() : <any>undefined;
        data["recurringIndicator"] = this.recurringIndicator;
        data["validUntil"] = this.validUntil ? this.validUntil.toISOString() : <any>undefined;
        data["frequencyPerDay"] = this.frequencyPerDay;
        data["lastActionDate"] = this.lastActionDate ? this.lastActionDate.toISOString() : <any>undefined;
        data["consentStatus"] = this.consentStatus;
        return data; 
    }
}

/** Body of the JSON response for a successfull get consent request. */
export interface IConsentInformationResponse200Json {
    /** Gets or Sets Access */
    access: AccountAccess;
    /** Gets or Sets RecurringIndicator */
    recurringIndicator: any;
    /** Gets or Sets ValidUntil */
    validUntil: Date;
    /** Gets or Sets FrequencyPerDay - This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one. */
    frequencyPerDay: number;
    /** Gets or Sets LastActionDate */
    lastActionDate: Date;
    /** Gets or Sets ConsentStatus */
    consentStatus: ConsentInformationResponse200JsonConsentStatus;
}

/** Requested access services for a consent. */
export class AccountAccess implements IAccountAccess {
    /** Is asking for detailed account information.   If the array is empty, the TPP is asking for an accessible account list.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for balances or transactions shall be empty, if used. */
    accounts?: AccountReference[] | undefined;
    /** Is asking for balances of the addressed accounts.  If the array is empty, the TPP is asking for the balances of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or transactions shall be empty, if used. */
    balances?: AccountReference[] | undefined;
    /** Is asking for transactions of the addressed accounts.   If the array is empty, the TPP is asking for the transactions of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or balances shall be empty, if used. */
    transactions?: AccountReference[] | undefined;
    /** Optional if supported by API provider.  Only the values \"allAccounts\" or \"allAccountsWithBalances\" is admitted. */
    availableAccounts?: AccountAccessAvailableAccounts | undefined;
    /** Optional if supported by API provider.  Only the value \"allAccounts\" is admitted. */
    allPsd2?: AccountAccessAllPsd2 | undefined;

    constructor(data?: IAccountAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accounts"] && data["accounts"].constructor === Array) {
                this.accounts = [] as any;
                for (let item of data["accounts"])
                    this.accounts!.push(AccountReference.fromJS(item));
            }
            if (data["balances"] && data["balances"].constructor === Array) {
                this.balances = [] as any;
                for (let item of data["balances"])
                    this.balances!.push(AccountReference.fromJS(item));
            }
            if (data["transactions"] && data["transactions"].constructor === Array) {
                this.transactions = [] as any;
                for (let item of data["transactions"])
                    this.transactions!.push(AccountReference.fromJS(item));
            }
            this.availableAccounts = data["availableAccounts"];
            this.allPsd2 = data["allPsd2"];
        }
    }

    static fromJS(data: any): AccountAccess {
        data = typeof data === 'object' ? data : {};
        let result = new AccountAccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accounts && this.accounts.constructor === Array) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (this.balances && this.balances.constructor === Array) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        if (this.transactions && this.transactions.constructor === Array) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        data["availableAccounts"] = this.availableAccounts;
        data["allPsd2"] = this.allPsd2;
        return data; 
    }
}

/** Requested access services for a consent. */
export interface IAccountAccess {
    /** Is asking for detailed account information.   If the array is empty, the TPP is asking for an accessible account list.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for balances or transactions shall be empty, if used. */
    accounts?: AccountReference[] | undefined;
    /** Is asking for balances of the addressed accounts.  If the array is empty, the TPP is asking for the balances of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or transactions shall be empty, if used. */
    balances?: AccountReference[] | undefined;
    /** Is asking for transactions of the addressed accounts.   If the array is empty, the TPP is asking for the transactions of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or balances shall be empty, if used. */
    transactions?: AccountReference[] | undefined;
    /** Optional if supported by API provider.  Only the values \"allAccounts\" or \"allAccountsWithBalances\" is admitted. */
    availableAccounts?: AccountAccessAvailableAccounts | undefined;
    /** Optional if supported by API provider.  Only the value \"allAccounts\" is admitted. */
    allPsd2?: AccountAccessAllPsd2 | undefined;
}

/** Reference to an account by either   * IBAN, of a payment accounts, or   * BBAN, for payment accounts if there is no IBAN, or    * the Primary Account Number (PAN) of a card, can be tokenised by the ASPSP due to PCI DSS requirements, or   * the Primary Account Number (PAN) of a card in a masked form, or   * an alias to access a payment account via a registered mobile phone number (MSISDN). */
export class AccountReference implements IAccountReference {
    /** Gets or Sets Iban */
    iban?: string | undefined;
    /** Gets or Sets Bban */
    bban?: string | undefined;
    /** Gets or Sets Pan */
    pan?: string | undefined;
    /** Gets or Sets MaskedPan */
    maskedPan?: string | undefined;
    /** Gets or Sets Msisdn */
    msisdn?: string | undefined;
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency?: string | undefined;

    constructor(data?: IAccountReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iban = data["iban"];
            this.bban = data["bban"];
            this.pan = data["pan"];
            this.maskedPan = data["maskedPan"];
            this.msisdn = data["msisdn"];
            this.currency = data["currency"];
        }
    }

    static fromJS(data: any): AccountReference {
        data = typeof data === 'object' ? data : {};
        let result = new AccountReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iban"] = this.iban;
        data["bban"] = this.bban;
        data["pan"] = this.pan;
        data["maskedPan"] = this.maskedPan;
        data["msisdn"] = this.msisdn;
        data["currency"] = this.currency;
        return data; 
    }
}

/** Reference to an account by either   * IBAN, of a payment accounts, or   * BBAN, for payment accounts if there is no IBAN, or    * the Primary Account Number (PAN) of a card, can be tokenised by the ASPSP due to PCI DSS requirements, or   * the Primary Account Number (PAN) of a card in a masked form, or   * an alias to access a payment account via a registered mobile phone number (MSISDN). */
export interface IAccountReference {
    /** Gets or Sets Iban */
    iban?: string | undefined;
    /** Gets or Sets Bban */
    bban?: string | undefined;
    /** Gets or Sets Pan */
    pan?: string | undefined;
    /** Gets or Sets MaskedPan */
    maskedPan?: string | undefined;
    /** Gets or Sets Msisdn */
    msisdn?: string | undefined;
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency?: string | undefined;
}

/** Body of the JSON response with SCA Status */
export class ScaStatusResponse implements IScaStatusResponse {
    /** Gets or Sets ScaStatus */
    scaStatus?: ScaStatusResponseScaStatus | undefined;

    constructor(data?: IScaStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scaStatus = data["scaStatus"];
        }
    }

    static fromJS(data: any): ScaStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScaStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scaStatus"] = this.scaStatus;
        return data; 
    }
}

/** Body of the JSON response with SCA Status */
export interface IScaStatusResponse {
    /** Gets or Sets ScaStatus */
    scaStatus?: ScaStatusResponseScaStatus | undefined;
}

/** Body of the JSON response for a successful get status request for a consent. */
export class ConsentStatusResponse200 implements IConsentStatusResponse200 {
    /** Gets or Sets ConsentStatus */
    consentStatus!: ConsentStatusResponse200ConsentStatus;

    constructor(data?: IConsentStatusResponse200) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.consentStatus = data["consentStatus"];
        }
    }

    static fromJS(data: any): ConsentStatusResponse200 {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentStatusResponse200();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consentStatus"] = this.consentStatus;
        return data; 
    }
}

/** Body of the JSON response for a successful get status request for a consent. */
export interface IConsentStatusResponse200 {
    /** Gets or Sets ConsentStatus */
    consentStatus: ConsentStatusResponse200ConsentStatus;
}

/** Transaction details */
export class TransactionDetails implements ITransactionDetails {
    /** the Transaction Id can be used as access-ID in the API, where more details on an transaction is offered.  If this data attribute is provided this shows that the AIS can get access on more details about this  transaction using the GET Transaction Details Request */
    transactionId?: string | undefined;
    /** Is the identification of the transaction as used e.g. for reference for deltafunction on application level.  The same identification as for example used within camt.05x messages. */
    entryReference?: string | undefined;
    /** Unique end to end identity. */
    endToEndId?: string | undefined;
    /** Identification of Mandates, e.g. a SEPA Mandate ID. */
    mandateId?: string | undefined;
    /** Identification of a Cheque. */
    checkId?: string | undefined;
    /** Identification of Creditors, e.g. a SEPA Creditor ID. */
    creditorId?: string | undefined;
    /** Gets or Sets BookingDate */
    bookingDate?: Date | undefined;
    /** The Date at which assets become available to the account owner in case of a credit. */
    valueDate?: Date | undefined;
    /** Gets or Sets TransactionAmount */
    transactionAmount!: Amount;
    /** Gets or Sets CurrencyExchange */
    currencyExchange?: ReportExchangeRate[] | undefined;
    /** Gets or Sets CreditorName */
    creditorName?: string | undefined;
    /** Gets or Sets CreditorAccount */
    creditorAccount?: AccountReference | undefined;
    /** Gets or Sets UltimateCreditor */
    ultimateCreditor?: string | undefined;
    /** Gets or Sets DebtorName */
    debtorName?: string | undefined;
    /** Gets or Sets DebtorAccount */
    debtorAccount?: AccountReference | undefined;
    /** Gets or Sets UltimateDebtor */
    ultimateDebtor?: string | undefined;
    /** Gets or Sets RemittanceInformationUnstructured */
    remittanceInformationUnstructured?: any | undefined;
    /** Reference as contained in the structured remittance reference structure (without the surrounding XML structure).  Different from other places the content is containt in plain form not in form of a structered field. */
    remittanceInformationStructured?: string | undefined;
    /** Might be used by the ASPSP to transport additional transaction related information to the PSU. */
    additionalInformation?: string | undefined;
    /** Gets or Sets PurposeCode */
    purposeCode?: TransactionDetailsPurposeCode | undefined;
    /** Gets or Sets BankTransactionCode - Bank transaction code as used by the ASPSP and using the sub elements of this structured code defined by ISO 20022.   
This code type is concatenating the three ISO20022 Codes    
* Domain Code,    * Family Code, and    * SubFamiliy Code  by hyphens, 
resulting in �DomainCode�-�FamilyCode�-�SubFamilyCode�. */
    bankTransactionCode?: string | undefined;
    /** Gets or Sets ProprietaryBankTransactionCode */
    proprietaryBankTransactionCode?: any | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: ITransactionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.transactionAmount = new Amount();
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.entryReference = data["entryReference"];
            this.endToEndId = data["endToEndId"];
            this.mandateId = data["mandateId"];
            this.checkId = data["checkId"];
            this.creditorId = data["creditorId"];
            this.bookingDate = data["bookingDate"] ? new Date(data["bookingDate"].toString()) : <any>undefined;
            this.valueDate = data["valueDate"] ? new Date(data["valueDate"].toString()) : <any>undefined;
            this.transactionAmount = data["transactionAmount"] ? Amount.fromJS(data["transactionAmount"]) : new Amount();
            if (data["currencyExchange"] && data["currencyExchange"].constructor === Array) {
                this.currencyExchange = [] as any;
                for (let item of data["currencyExchange"])
                    this.currencyExchange!.push(ReportExchangeRate.fromJS(item));
            }
            this.creditorName = data["creditorName"];
            this.creditorAccount = data["creditorAccount"] ? AccountReference.fromJS(data["creditorAccount"]) : <any>undefined;
            this.ultimateCreditor = data["ultimateCreditor"];
            this.debtorName = data["debtorName"];
            this.debtorAccount = data["debtorAccount"] ? AccountReference.fromJS(data["debtorAccount"]) : <any>undefined;
            this.ultimateDebtor = data["ultimateDebtor"];
            this.remittanceInformationUnstructured = data["remittanceInformationUnstructured"];
            this.remittanceInformationStructured = data["remittanceInformationStructured"];
            this.additionalInformation = data["additionalInformation"];
            this.purposeCode = data["purposeCode"];
            this.bankTransactionCode = data["bankTransactionCode"];
            this.proprietaryBankTransactionCode = data["proprietaryBankTransactionCode"];
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): TransactionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["entryReference"] = this.entryReference;
        data["endToEndId"] = this.endToEndId;
        data["mandateId"] = this.mandateId;
        data["checkId"] = this.checkId;
        data["creditorId"] = this.creditorId;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toISOString() : <any>undefined;
        data["valueDate"] = this.valueDate ? this.valueDate.toISOString() : <any>undefined;
        data["transactionAmount"] = this.transactionAmount ? this.transactionAmount.toJSON() : <any>undefined;
        if (this.currencyExchange && this.currencyExchange.constructor === Array) {
            data["currencyExchange"] = [];
            for (let item of this.currencyExchange)
                data["currencyExchange"].push(item.toJSON());
        }
        data["creditorName"] = this.creditorName;
        data["creditorAccount"] = this.creditorAccount ? this.creditorAccount.toJSON() : <any>undefined;
        data["ultimateCreditor"] = this.ultimateCreditor;
        data["debtorName"] = this.debtorName;
        data["debtorAccount"] = this.debtorAccount ? this.debtorAccount.toJSON() : <any>undefined;
        data["ultimateDebtor"] = this.ultimateDebtor;
        data["remittanceInformationUnstructured"] = this.remittanceInformationUnstructured;
        data["remittanceInformationStructured"] = this.remittanceInformationStructured;
        data["additionalInformation"] = this.additionalInformation;
        data["purposeCode"] = this.purposeCode;
        data["bankTransactionCode"] = this.bankTransactionCode;
        data["proprietaryBankTransactionCode"] = this.proprietaryBankTransactionCode;
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** Transaction details */
export interface ITransactionDetails {
    /** the Transaction Id can be used as access-ID in the API, where more details on an transaction is offered.  If this data attribute is provided this shows that the AIS can get access on more details about this  transaction using the GET Transaction Details Request */
    transactionId?: string | undefined;
    /** Is the identification of the transaction as used e.g. for reference for deltafunction on application level.  The same identification as for example used within camt.05x messages. */
    entryReference?: string | undefined;
    /** Unique end to end identity. */
    endToEndId?: string | undefined;
    /** Identification of Mandates, e.g. a SEPA Mandate ID. */
    mandateId?: string | undefined;
    /** Identification of a Cheque. */
    checkId?: string | undefined;
    /** Identification of Creditors, e.g. a SEPA Creditor ID. */
    creditorId?: string | undefined;
    /** Gets or Sets BookingDate */
    bookingDate?: Date | undefined;
    /** The Date at which assets become available to the account owner in case of a credit. */
    valueDate?: Date | undefined;
    /** Gets or Sets TransactionAmount */
    transactionAmount: Amount;
    /** Gets or Sets CurrencyExchange */
    currencyExchange?: ReportExchangeRate[] | undefined;
    /** Gets or Sets CreditorName */
    creditorName?: string | undefined;
    /** Gets or Sets CreditorAccount */
    creditorAccount?: AccountReference | undefined;
    /** Gets or Sets UltimateCreditor */
    ultimateCreditor?: string | undefined;
    /** Gets or Sets DebtorName */
    debtorName?: string | undefined;
    /** Gets or Sets DebtorAccount */
    debtorAccount?: AccountReference | undefined;
    /** Gets or Sets UltimateDebtor */
    ultimateDebtor?: string | undefined;
    /** Gets or Sets RemittanceInformationUnstructured */
    remittanceInformationUnstructured?: any | undefined;
    /** Reference as contained in the structured remittance reference structure (without the surrounding XML structure).  Different from other places the content is containt in plain form not in form of a structered field. */
    remittanceInformationStructured?: string | undefined;
    /** Might be used by the ASPSP to transport additional transaction related information to the PSU. */
    additionalInformation?: string | undefined;
    /** Gets or Sets PurposeCode */
    purposeCode?: TransactionDetailsPurposeCode | undefined;
    /** Gets or Sets BankTransactionCode - Bank transaction code as used by the ASPSP and using the sub elements of this structured code defined by ISO 20022.   
This code type is concatenating the three ISO20022 Codes    
* Domain Code,    * Family Code, and    * SubFamiliy Code  by hyphens, 
resulting in �DomainCode�-�FamilyCode�-�SubFamilyCode�. */
    bankTransactionCode?: string | undefined;
    /** Gets or Sets ProprietaryBankTransactionCode */
    proprietaryBankTransactionCode?: any | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class Amount implements IAmount {
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency!: string;
    /** Gets or Sets _Amount */
    amount!: number;

    constructor(data?: IAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["currency"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): Amount {
        data = typeof data === 'object' ? data : {};
        let result = new Amount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IAmount {
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency: string;
    /** Gets or Sets _Amount */
    amount: number;
}

/** Exchange Rate */
export class ReportExchangeRate implements IReportExchangeRate {
    /** Gets or Sets SourceCurrency - ISO 4217 Alpha 3 currency code */
    sourceCurrency!: string;
    /** Gets or Sets ExchangeRate */
    exchangeRate!: string;
    /** Gets or Sets UnitCurrency */
    unitCurrency!: string;
    /** Gets or Sets TargetCurrency - ISO 4217 Alpha 3 currency code */
    targetCurrency!: string;
    /** Gets or Sets QuotationDate */
    quotationDate!: Date;
    /** Gets or Sets ContractIdentification */
    contractIdentification?: string | undefined;

    constructor(data?: IReportExchangeRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceCurrency = data["sourceCurrency"];
            this.exchangeRate = data["exchangeRate"];
            this.unitCurrency = data["unitCurrency"];
            this.targetCurrency = data["targetCurrency"];
            this.quotationDate = data["quotationDate"] ? new Date(data["quotationDate"].toString()) : <any>undefined;
            this.contractIdentification = data["contractIdentification"];
        }
    }

    static fromJS(data: any): ReportExchangeRate {
        data = typeof data === 'object' ? data : {};
        let result = new ReportExchangeRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCurrency"] = this.sourceCurrency;
        data["exchangeRate"] = this.exchangeRate;
        data["unitCurrency"] = this.unitCurrency;
        data["targetCurrency"] = this.targetCurrency;
        data["quotationDate"] = this.quotationDate ? this.quotationDate.toISOString() : <any>undefined;
        data["contractIdentification"] = this.contractIdentification;
        return data; 
    }
}

/** Exchange Rate */
export interface IReportExchangeRate {
    /** Gets or Sets SourceCurrency - ISO 4217 Alpha 3 currency code */
    sourceCurrency: string;
    /** Gets or Sets ExchangeRate */
    exchangeRate: string;
    /** Gets or Sets UnitCurrency */
    unitCurrency: string;
    /** Gets or Sets TargetCurrency - ISO 4217 Alpha 3 currency code */
    targetCurrency: string;
    /** Gets or Sets QuotationDate */
    quotationDate: Date;
    /** Gets or Sets ContractIdentification */
    contractIdentification?: string | undefined;
}

/** Body of the JSON response for a successful read transaction list request. This account report contains transactions resulting from the query parameters. */
export class TransactionsResponse200Json implements ITransactionsResponse200Json {
    /** Gets or Sets Account */
    account?: AccountReference | undefined;
    /** Gets or Sets Transactions */
    transactions?: AccountReport | undefined;
    /** Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance. */
    balances?: Balance[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: ITransactionsResponse200Json) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountReference.fromJS(data["account"]) : <any>undefined;
            this.transactions = data["transactions"] ? AccountReport.fromJS(data["transactions"]) : <any>undefined;
            if (data["balances"] && data["balances"].constructor === Array) {
                this.balances = [] as any;
                for (let item of data["balances"])
                    this.balances!.push(Balance.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): TransactionsResponse200Json {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsResponse200Json();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["transactions"] = this.transactions ? this.transactions.toJSON() : <any>undefined;
        if (this.balances && this.balances.constructor === Array) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** Body of the JSON response for a successful read transaction list request. This account report contains transactions resulting from the query parameters. */
export interface ITransactionsResponse200Json {
    /** Gets or Sets Account */
    account?: AccountReference | undefined;
    /** Gets or Sets Transactions */
    transactions?: AccountReport | undefined;
    /** Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance. */
    balances?: Balance[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

/** JSON based account report. This account report contains transactions resulting from the query parameters.  'booked' shall be contained if bookingStatus parameter is set to \"booked\" or \"both\".  'pending' is not contained if the bookingStatus parameter is set to \"booked\". */
export class AccountReport implements IAccountReport {
    /** Gets or Sets Booked */
    booked?: TransactionDetails[] | undefined;
    /** Gets or Sets Pending */
    pending?: TransactionDetails[] | undefined;
    /** Gets or Sets Links */
    _links!: { [key: string] : HrefType; };

    constructor(data?: IAccountReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this._links = {};
        }
    }

    init(data?: any) {
        if (data) {
            if (data["booked"] && data["booked"].constructor === Array) {
                this.booked = [] as any;
                for (let item of data["booked"])
                    this.booked!.push(TransactionDetails.fromJS(item));
            }
            if (data["pending"] && data["pending"].constructor === Array) {
                this.pending = [] as any;
                for (let item of data["pending"])
                    this.pending!.push(TransactionDetails.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): AccountReport {
        data = typeof data === 'object' ? data : {};
        let result = new AccountReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.booked && this.booked.constructor === Array) {
            data["booked"] = [];
            for (let item of this.booked)
                data["booked"].push(item.toJSON());
        }
        if (this.pending && this.pending.constructor === Array) {
            data["pending"] = [];
            for (let item of this.pending)
                data["pending"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** JSON based account report. This account report contains transactions resulting from the query parameters.  'booked' shall be contained if bookingStatus parameter is set to \"booked\" or \"both\".  'pending' is not contained if the bookingStatus parameter is set to \"booked\". */
export interface IAccountReport {
    /** Gets or Sets Booked */
    booked?: TransactionDetails[] | undefined;
    /** Gets or Sets Pending */
    pending?: TransactionDetails[] | undefined;
    /** Gets or Sets Links */
    _links: { [key: string] : HrefType; };
}

/** A single balance element */
export class Balance implements IBalance {
    /** Gets or Sets BalanceAmount */
    balanceAmount!: Amount;
    /** Gets or Sets BalanceType */
    balanceType!: BalanceType;
    /** This data element might be used to indicate e.g. with the expected or booked balance that no action is known  on the account, which is not yet booked. */
    lastChangeDateTime?: Date | undefined;
    /** Reference date of the balance */
    referenceDate?: Date | undefined;
    /** \"entryReference\" of the last commited transaction to support the TPP in identifying whether all  PSU transactions are already known. */
    lastCommittedTransaction?: string | undefined;

    constructor(data?: IBalance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.balanceAmount = new Amount();
        }
    }

    init(data?: any) {
        if (data) {
            this.balanceAmount = data["balanceAmount"] ? Amount.fromJS(data["balanceAmount"]) : new Amount();
            this.balanceType = data["balanceType"];
            this.lastChangeDateTime = data["lastChangeDateTime"] ? new Date(data["lastChangeDateTime"].toString()) : <any>undefined;
            this.referenceDate = data["referenceDate"] ? new Date(data["referenceDate"].toString()) : <any>undefined;
            this.lastCommittedTransaction = data["lastCommittedTransaction"];
        }
    }

    static fromJS(data: any): Balance {
        data = typeof data === 'object' ? data : {};
        let result = new Balance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceAmount"] = this.balanceAmount ? this.balanceAmount.toJSON() : <any>undefined;
        data["balanceType"] = this.balanceType;
        data["lastChangeDateTime"] = this.lastChangeDateTime ? this.lastChangeDateTime.toISOString() : <any>undefined;
        data["referenceDate"] = this.referenceDate ? this.referenceDate.toISOString() : <any>undefined;
        data["lastCommittedTransaction"] = this.lastCommittedTransaction;
        return data; 
    }
}

/** A single balance element */
export interface IBalance {
    /** Gets or Sets BalanceAmount */
    balanceAmount: Amount;
    /** Gets or Sets BalanceType */
    balanceType: BalanceType;
    /** This data element might be used to indicate e.g. with the expected or booked balance that no action is known  on the account, which is not yet booked. */
    lastChangeDateTime?: Date | undefined;
    /** Reference date of the balance */
    referenceDate?: Date | undefined;
    /** \"entryReference\" of the last commited transaction to support the TPP in identifying whether all  PSU transactions are already known. */
    lastCommittedTransaction?: string | undefined;
}

/** The ASPSP shall give at least one of the account reference identifiers:   - iban   - bban   - pan   - maskedPan   - msisdn If the account is a multicurrency account currency code in \"currency\" is set to \"XXX\". */
export class AccountDetails implements IAccountDetails {
    /** This shall be filled, if addressable resource are created by the ASPSP on the /accounts or /card-accounts endpoint. */
    resourceId?: string | undefined;
    /** Gets or Sets Iban */
    iban?: string | undefined;
    /** Gets or Sets Bban */
    bban?: string | undefined;
    /** Gets or Sets Msisdn */
    msisdn?: string | undefined;
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency!: string;
    /** Name of the account given by the bank or the PSU in online-banking. */
    name?: string | undefined;
    /** Product name of the bank for this account, proprietary definition. */
    product?: string | undefined;
    /** Gets or Sets CashAccountType - ExternalCashAccountType1Code from ISO 20022. */
    cashAccountType?: string | undefined;
    /** Gets or Sets Status */
    status?: AccountDetailsStatus | undefined;
    /** Gets or Sets Bic */
    bic?: string | undefined;
    /** Case of a set of pending card transactions, the APSP will provide the relevant cash account the card is set up on. */
    linkedAccounts?: string | undefined;
    /** Specifies the usage of the account   * PRIV: private personal account   * ORGA: professional account */
    usage?: AccountDetailsUsage | undefined;
    /** Specifications that might be provided by the ASPSP   - characteristics of the account   - characteristics of the relevant card */
    details?: string | undefined;
    /** Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance. */
    balances?: Balance[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IAccountDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resourceId = data["resourceId"];
            this.iban = data["iban"];
            this.bban = data["bban"];
            this.msisdn = data["msisdn"];
            this.currency = data["currency"];
            this.name = data["name"];
            this.product = data["product"];
            this.cashAccountType = data["cashAccountType"];
            this.status = data["status"];
            this.bic = data["bic"];
            this.linkedAccounts = data["linkedAccounts"];
            this.usage = data["usage"];
            this.details = data["details"];
            if (data["balances"] && data["balances"].constructor === Array) {
                this.balances = [] as any;
                for (let item of data["balances"])
                    this.balances!.push(Balance.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): AccountDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["iban"] = this.iban;
        data["bban"] = this.bban;
        data["msisdn"] = this.msisdn;
        data["currency"] = this.currency;
        data["name"] = this.name;
        data["product"] = this.product;
        data["cashAccountType"] = this.cashAccountType;
        data["status"] = this.status;
        data["bic"] = this.bic;
        data["linkedAccounts"] = this.linkedAccounts;
        data["usage"] = this.usage;
        data["details"] = this.details;
        if (this.balances && this.balances.constructor === Array) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** The ASPSP shall give at least one of the account reference identifiers:   - iban   - bban   - pan   - maskedPan   - msisdn If the account is a multicurrency account currency code in \"currency\" is set to \"XXX\". */
export interface IAccountDetails {
    /** This shall be filled, if addressable resource are created by the ASPSP on the /accounts or /card-accounts endpoint. */
    resourceId?: string | undefined;
    /** Gets or Sets Iban */
    iban?: string | undefined;
    /** Gets or Sets Bban */
    bban?: string | undefined;
    /** Gets or Sets Msisdn */
    msisdn?: string | undefined;
    /** Gets or Sets Currency - ISO 4217 Alpha 3 currency code */
    currency: string;
    /** Name of the account given by the bank or the PSU in online-banking. */
    name?: string | undefined;
    /** Product name of the bank for this account, proprietary definition. */
    product?: string | undefined;
    /** Gets or Sets CashAccountType - ExternalCashAccountType1Code from ISO 20022. */
    cashAccountType?: string | undefined;
    /** Gets or Sets Status */
    status?: AccountDetailsStatus | undefined;
    /** Gets or Sets Bic */
    bic?: string | undefined;
    /** Case of a set of pending card transactions, the APSP will provide the relevant cash account the card is set up on. */
    linkedAccounts?: string | undefined;
    /** Specifies the usage of the account   * PRIV: private personal account   * ORGA: professional account */
    usage?: AccountDetailsUsage | undefined;
    /** Specifications that might be provided by the ASPSP   - characteristics of the account   - characteristics of the relevant card */
    details?: string | undefined;
    /** Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance. */
    balances?: Balance[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

/** JSON Request body for the \"Confirmation of Funds Service\"  &lt;table&gt;  &lt;tr&gt;    &lt;td&gt;cardNumber&lt;/td&gt;    &lt;td&gt;String &lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;Card Number of the card issued by the PIISP. Should be delivered if available.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;account&lt;/td&gt;   &lt;td&gt; Account Reference&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;PSU's account number.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;payee&lt;/td&gt;   &lt;td&gt;Max70Text&lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;The merchant where the card is accepted as an information to the PSU.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;instructedAmount&lt;/td&gt;   &lt;td&gt;Amount&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;Transaction amount to be checked within the funds check mechanism.&lt;/td&gt; &lt;/tr&gt;  &lt;/table&gt; */
export class ConfirmationOfFunds implements IConfirmationOfFunds {
    /** Card Number of the card issued by the PIISP.  Should be delivered if available. */
    cardNumber?: string | undefined;
    /** Gets or Sets Account */
    account!: AccountReference;
    /** Name payee */
    payee?: string | undefined;
    /** Gets or Sets InstructedAmount */
    instructedAmount!: Amount;

    constructor(data?: IConfirmationOfFunds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.account = new AccountReference();
            this.instructedAmount = new Amount();
        }
    }

    init(data?: any) {
        if (data) {
            this.cardNumber = data["cardNumber"];
            this.account = data["account"] ? AccountReference.fromJS(data["account"]) : new AccountReference();
            this.payee = data["payee"];
            this.instructedAmount = data["instructedAmount"] ? Amount.fromJS(data["instructedAmount"]) : new Amount();
        }
    }

    static fromJS(data: any): ConfirmationOfFunds {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmationOfFunds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNumber"] = this.cardNumber;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["payee"] = this.payee;
        data["instructedAmount"] = this.instructedAmount ? this.instructedAmount.toJSON() : <any>undefined;
        return data; 
    }
}

/** JSON Request body for the \"Confirmation of Funds Service\"  &lt;table&gt;  &lt;tr&gt;    &lt;td&gt;cardNumber&lt;/td&gt;    &lt;td&gt;String &lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;Card Number of the card issued by the PIISP. Should be delivered if available.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;account&lt;/td&gt;   &lt;td&gt; Account Reference&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;PSU's account number.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;payee&lt;/td&gt;   &lt;td&gt;Max70Text&lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;The merchant where the card is accepted as an information to the PSU.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;instructedAmount&lt;/td&gt;   &lt;td&gt;Amount&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;Transaction amount to be checked within the funds check mechanism.&lt;/td&gt; &lt;/tr&gt;  &lt;/table&gt; */
export interface IConfirmationOfFunds {
    /** Card Number of the card issued by the PIISP.  Should be delivered if available. */
    cardNumber?: string | undefined;
    /** Gets or Sets Account */
    account: AccountReference;
    /** Name payee */
    payee?: string | undefined;
    /** Gets or Sets InstructedAmount */
    instructedAmount: Amount;
}

/** Equals \"true\" if sufficient funds are available at the time of the request,  \"false\" otherwise. */
export class ConfirmationOfFundsResponse200 implements IConfirmationOfFundsResponse200 {
    /** Gets or Sets FundsAvailable */
    fundsAvailable?: boolean | undefined;

    constructor(data?: IConfirmationOfFundsResponse200) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fundsAvailable = data["fundsAvailable"];
        }
    }

    static fromJS(data: any): ConfirmationOfFundsResponse200 {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmationOfFundsResponse200();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundsAvailable"] = this.fundsAvailable;
        return data; 
    }
}

/** Equals \"true\" if sufficient funds are available at the time of the request,  \"false\" otherwise. */
export interface IConfirmationOfFundsResponse200 {
    /** Gets or Sets FundsAvailable */
    fundsAvailable?: boolean | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error401NGPIIS implements IError401NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError401NGPIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage401PIIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error401NGPIIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error401NGPIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError401NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage401PIIS implements ITppMessage401PIIS {
    /** Gets or Sets Category */
    category!: TppMessage401PIISCategory;
    /** Gets or Sets Code */
    code!: TppMessage401PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage401PIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage401PIIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage401PIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage401PIIS {
    /** Gets or Sets Category */
    category: TppMessage401PIISCategory;
    /** Gets or Sets Code */
    code: TppMessage401PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export class Error403NGPIIS implements IError403NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError403NGPIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage403PIIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error403NGPIIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error403NGPIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export interface IError403NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage403PIIS implements ITppMessage403PIIS {
    /** Gets or Sets Category */
    category!: TppMessage403PIISCategory;
    /** Gets or Sets Code */
    code!: TppMessage403PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage403PIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage403PIIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage403PIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage403PIIS {
    /** Gets or Sets Category */
    category: TppMessage403PIISCategory;
    /** Gets or Sets Code */
    code: TppMessage403PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export class Error404NGPIIS implements IError404NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError404NGPIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage404PIIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error404NGPIIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error404NGPIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export interface IError404NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage404PIIS implements ITppMessage404PIIS {
    /** Gets or Sets Category */
    category!: TppMessage404PIISCategory;
    /** Gets or Sets Code */
    code!: TppMessage404PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage404PIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage404PIIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage404PIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage404PIIS {
    /** Gets or Sets Category */
    category: TppMessage404PIISCategory;
    /** Gets or Sets Code */
    code: TppMessage404PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error405NGPIIS implements IError405NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError405NGPIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage405PIIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error405NGPIIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error405NGPIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError405NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage405PIIS implements ITppMessage405PIIS {
    /** Gets or Sets Category */
    category!: TppMessage405PIISCategory;
    /** Gets or Sets Code */
    code!: TppMessage405PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage405PIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage405PIIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage405PIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage405PIIS {
    /** Gets or Sets Category */
    category: TppMessage405PIISCategory;
    /** Gets or Sets Code */
    code: TppMessage405PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export class Error409NGPIIS implements IError409NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError409NGPIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage409PIIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error409NGPIIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error409NGPIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export interface IError409NGPIIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409PIIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage409PIIS implements ITppMessage409PIIS {
    /** Gets or Sets Category */
    category!: TppMessage409PIISCategory;
    /** Gets or Sets Code */
    code!: TppMessage409PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage409PIIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage409PIIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage409PIIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage409PIIS {
    /** Gets or Sets Category */
    category: TppMessage409PIISCategory;
    /** Gets or Sets Code */
    code: TppMessage409PIISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

export class Branch implements IBranch {
    /** Organisation */
    organisation!: Organisation;
    /** Name by which a party is known and which is usually used to identify that party */
    branchName?: string | undefined;
    /** Unique and unambiguous identification of a retail branch of a financial institution */
    branchIdentification!: string;
    /** Information on the type of branch */
    branchType!: BranchType;
    /** Postal Address */
    address!: Address;
    /** Description of the branch */
    branchDescription?: string | undefined;
    /** Image related to the branch */
    branchPhoto?: string | undefined;
    /** Collection of information that identifies a phone number, as defined by telecom services. */
    telephoneNumber!: string;
    alternatePhone?: string[] | undefined;
    /** Collection of information that identifies a FAX number, as defined by telecom services. */
    faxNumber?: string[] | undefined;
    /** Geographic Coordinates */
    geographicLocation?: GeographicLocation | undefined;
    /** Description on when the mobile branch is available. e.g. The weekend of Glastonbury festival; or Mondays and during the shrimp season also Wednesdays */
    daysOfTheWeek?: string | undefined;
    /** Name of the stop of the mobile branch */
    stopName?: string | undefined;
    /** Time that the mobile branch is scheduled to arrive */
    arrivalTime?: string | undefined;
    /** Time that the mobile branch is scheduled to depart */
    departureTime?: string | undefined;
    /** Place where the mobile branch is located, such as between the news agent and the church. */
    parkingLocation?: string | undefined;
    /** Branch Opening Times */
    openingTimes!: OpeningTimeInfo[];
    plannedBranchClosure?: PlannedBranchClosure[] | undefined;
    /** Information about the accessibility */
    accessibilityTypes?: BranchAccessibilityTypes | undefined;
    branchSelfServeServiceName?: BranchSelfServeServiceName[] | undefined;
    /** Self Services not described in BranchSelfServeServiceName */
    branchOtherSelfServices?: string[] | undefined;
    /** Information about mediated branch facilities */
    branchMediatedServiceName?: BranchMediatedServiceName[] | undefined;
    /** Mediated Services not described in BranchMediatedServiceName */
    branchOtherMediatedServices?: string[] | undefined;
    /** Information about branch facilities */
    branchFacilitiesName?: BranchFacilitiesName[] | undefined;
    /** Customer segment which the branch is able to service */
    customerSegment!: CustomerSegment[];
    /** Any other facilities not mentioned in BranchFacilitiesName */
    branchOtherFacilities?: string[] | undefined;
    /** Indicated whether an ATM is at the branch */
    atmAtBranch!: boolean;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organisation = new Organisation();
            this.address = new Address();
            this.openingTimes = [];
            this.customerSegment = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.organisation = data["organisation"] ? Organisation.fromJS(data["organisation"]) : new Organisation();
            this.branchName = data["branchName"];
            this.branchIdentification = data["branchIdentification"];
            this.branchType = data["branchType"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.branchDescription = data["branchDescription"];
            this.branchPhoto = data["branchPhoto"];
            this.telephoneNumber = data["telephoneNumber"];
            if (data["alternatePhone"] && data["alternatePhone"].constructor === Array) {
                this.alternatePhone = [] as any;
                for (let item of data["alternatePhone"])
                    this.alternatePhone!.push(item);
            }
            if (data["faxNumber"] && data["faxNumber"].constructor === Array) {
                this.faxNumber = [] as any;
                for (let item of data["faxNumber"])
                    this.faxNumber!.push(item);
            }
            this.geographicLocation = data["geographicLocation"] ? GeographicLocation.fromJS(data["geographicLocation"]) : <any>undefined;
            this.daysOfTheWeek = data["daysOfTheWeek"];
            this.stopName = data["stopName"];
            this.arrivalTime = data["arrivalTime"];
            this.departureTime = data["departureTime"];
            this.parkingLocation = data["parkingLocation"];
            if (data["openingTimes"] && data["openingTimes"].constructor === Array) {
                this.openingTimes = [] as any;
                for (let item of data["openingTimes"])
                    this.openingTimes!.push(OpeningTimeInfo.fromJS(item));
            }
            if (data["plannedBranchClosure"] && data["plannedBranchClosure"].constructor === Array) {
                this.plannedBranchClosure = [] as any;
                for (let item of data["plannedBranchClosure"])
                    this.plannedBranchClosure!.push(PlannedBranchClosure.fromJS(item));
            }
            this.accessibilityTypes = data["accessibilityTypes"];
            if (data["branchSelfServeServiceName"] && data["branchSelfServeServiceName"].constructor === Array) {
                this.branchSelfServeServiceName = [] as any;
                for (let item of data["branchSelfServeServiceName"])
                    this.branchSelfServeServiceName!.push(item);
            }
            if (data["branchOtherSelfServices"] && data["branchOtherSelfServices"].constructor === Array) {
                this.branchOtherSelfServices = [] as any;
                for (let item of data["branchOtherSelfServices"])
                    this.branchOtherSelfServices!.push(item);
            }
            if (data["branchMediatedServiceName"] && data["branchMediatedServiceName"].constructor === Array) {
                this.branchMediatedServiceName = [] as any;
                for (let item of data["branchMediatedServiceName"])
                    this.branchMediatedServiceName!.push(item);
            }
            if (data["branchOtherMediatedServices"] && data["branchOtherMediatedServices"].constructor === Array) {
                this.branchOtherMediatedServices = [] as any;
                for (let item of data["branchOtherMediatedServices"])
                    this.branchOtherMediatedServices!.push(item);
            }
            if (data["branchFacilitiesName"] && data["branchFacilitiesName"].constructor === Array) {
                this.branchFacilitiesName = [] as any;
                for (let item of data["branchFacilitiesName"])
                    this.branchFacilitiesName!.push(item);
            }
            if (data["customerSegment"] && data["customerSegment"].constructor === Array) {
                this.customerSegment = [] as any;
                for (let item of data["customerSegment"])
                    this.customerSegment!.push(item);
            }
            if (data["branchOtherFacilities"] && data["branchOtherFacilities"].constructor === Array) {
                this.branchOtherFacilities = [] as any;
                for (let item of data["branchOtherFacilities"])
                    this.branchOtherFacilities!.push(item);
            }
            this.atmAtBranch = data["atmAtBranch"];
        }
    }

    static fromJS(data: any): Branch {
        data = typeof data === 'object' ? data : {};
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["branchName"] = this.branchName;
        data["branchIdentification"] = this.branchIdentification;
        data["branchType"] = this.branchType;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["branchDescription"] = this.branchDescription;
        data["branchPhoto"] = this.branchPhoto;
        data["telephoneNumber"] = this.telephoneNumber;
        if (this.alternatePhone && this.alternatePhone.constructor === Array) {
            data["alternatePhone"] = [];
            for (let item of this.alternatePhone)
                data["alternatePhone"].push(item);
        }
        if (this.faxNumber && this.faxNumber.constructor === Array) {
            data["faxNumber"] = [];
            for (let item of this.faxNumber)
                data["faxNumber"].push(item);
        }
        data["geographicLocation"] = this.geographicLocation ? this.geographicLocation.toJSON() : <any>undefined;
        data["daysOfTheWeek"] = this.daysOfTheWeek;
        data["stopName"] = this.stopName;
        data["arrivalTime"] = this.arrivalTime;
        data["departureTime"] = this.departureTime;
        data["parkingLocation"] = this.parkingLocation;
        if (this.openingTimes && this.openingTimes.constructor === Array) {
            data["openingTimes"] = [];
            for (let item of this.openingTimes)
                data["openingTimes"].push(item.toJSON());
        }
        if (this.plannedBranchClosure && this.plannedBranchClosure.constructor === Array) {
            data["plannedBranchClosure"] = [];
            for (let item of this.plannedBranchClosure)
                data["plannedBranchClosure"].push(item.toJSON());
        }
        data["accessibilityTypes"] = this.accessibilityTypes;
        if (this.branchSelfServeServiceName && this.branchSelfServeServiceName.constructor === Array) {
            data["branchSelfServeServiceName"] = [];
            for (let item of this.branchSelfServeServiceName)
                data["branchSelfServeServiceName"].push(item);
        }
        if (this.branchOtherSelfServices && this.branchOtherSelfServices.constructor === Array) {
            data["branchOtherSelfServices"] = [];
            for (let item of this.branchOtherSelfServices)
                data["branchOtherSelfServices"].push(item);
        }
        if (this.branchMediatedServiceName && this.branchMediatedServiceName.constructor === Array) {
            data["branchMediatedServiceName"] = [];
            for (let item of this.branchMediatedServiceName)
                data["branchMediatedServiceName"].push(item);
        }
        if (this.branchOtherMediatedServices && this.branchOtherMediatedServices.constructor === Array) {
            data["branchOtherMediatedServices"] = [];
            for (let item of this.branchOtherMediatedServices)
                data["branchOtherMediatedServices"].push(item);
        }
        if (this.branchFacilitiesName && this.branchFacilitiesName.constructor === Array) {
            data["branchFacilitiesName"] = [];
            for (let item of this.branchFacilitiesName)
                data["branchFacilitiesName"].push(item);
        }
        if (this.customerSegment && this.customerSegment.constructor === Array) {
            data["customerSegment"] = [];
            for (let item of this.customerSegment)
                data["customerSegment"].push(item);
        }
        if (this.branchOtherFacilities && this.branchOtherFacilities.constructor === Array) {
            data["branchOtherFacilities"] = [];
            for (let item of this.branchOtherFacilities)
                data["branchOtherFacilities"].push(item);
        }
        data["atmAtBranch"] = this.atmAtBranch;
        return data; 
    }
}

export interface IBranch {
    /** Organisation */
    organisation: Organisation;
    /** Name by which a party is known and which is usually used to identify that party */
    branchName?: string | undefined;
    /** Unique and unambiguous identification of a retail branch of a financial institution */
    branchIdentification: string;
    /** Information on the type of branch */
    branchType: BranchType;
    /** Postal Address */
    address: Address;
    /** Description of the branch */
    branchDescription?: string | undefined;
    /** Image related to the branch */
    branchPhoto?: string | undefined;
    /** Collection of information that identifies a phone number, as defined by telecom services. */
    telephoneNumber: string;
    alternatePhone?: string[] | undefined;
    /** Collection of information that identifies a FAX number, as defined by telecom services. */
    faxNumber?: string[] | undefined;
    /** Geographic Coordinates */
    geographicLocation?: GeographicLocation | undefined;
    /** Description on when the mobile branch is available. e.g. The weekend of Glastonbury festival; or Mondays and during the shrimp season also Wednesdays */
    daysOfTheWeek?: string | undefined;
    /** Name of the stop of the mobile branch */
    stopName?: string | undefined;
    /** Time that the mobile branch is scheduled to arrive */
    arrivalTime?: string | undefined;
    /** Time that the mobile branch is scheduled to depart */
    departureTime?: string | undefined;
    /** Place where the mobile branch is located, such as between the news agent and the church. */
    parkingLocation?: string | undefined;
    /** Branch Opening Times */
    openingTimes: OpeningTimeInfo[];
    plannedBranchClosure?: PlannedBranchClosure[] | undefined;
    /** Information about the accessibility */
    accessibilityTypes?: BranchAccessibilityTypes | undefined;
    branchSelfServeServiceName?: BranchSelfServeServiceName[] | undefined;
    /** Self Services not described in BranchSelfServeServiceName */
    branchOtherSelfServices?: string[] | undefined;
    /** Information about mediated branch facilities */
    branchMediatedServiceName?: BranchMediatedServiceName[] | undefined;
    /** Mediated Services not described in BranchMediatedServiceName */
    branchOtherMediatedServices?: string[] | undefined;
    /** Information about branch facilities */
    branchFacilitiesName?: BranchFacilitiesName[] | undefined;
    /** Customer segment which the branch is able to service */
    customerSegment: CustomerSegment[];
    /** Any other facilities not mentioned in BranchFacilitiesName */
    branchOtherFacilities?: string[] | undefined;
    /** Indicated whether an ATM is at the branch */
    atmAtBranch: boolean;
}

/** Organisation */
export class Organisation implements IOrganisation {
    /** Parent organisation */
    parentOrganisation!: ParentOrganisation;
    /** Brand */
    brand!: Brand;

    constructor(data?: IOrganisation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parentOrganisation = new ParentOrganisation();
            this.brand = new Brand();
        }
    }

    init(data?: any) {
        if (data) {
            this.parentOrganisation = data["parentOrganisation"] ? ParentOrganisation.fromJS(data["parentOrganisation"]) : new ParentOrganisation();
            this.brand = data["brand"] ? Brand.fromJS(data["brand"]) : new Brand();
        }
    }

    static fromJS(data: any): Organisation {
        data = typeof data === 'object' ? data : {};
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentOrganisation"] = this.parentOrganisation ? this.parentOrganisation.toJSON() : <any>undefined;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        return data; 
    }
}

/** Organisation */
export interface IOrganisation {
    /** Parent organisation */
    parentOrganisation: ParentOrganisation;
    /** Brand */
    brand: Brand;
}

export class Address implements IAddress {
    /** Gets or Sets Street */
    street?: string | undefined;
    /** Gets or Sets BuildingNumber */
    buildingNumber?: string | undefined;
    /** Gets or Sets City */
    city?: string | undefined;
    /** Gets or Sets PostalCode */
    postalCode?: string | undefined;
    /** Gets or Sets Country - ISO 3166 ALPHA2 country code */
    country!: string;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.street = data["street"];
            this.buildingNumber = data["buildingNumber"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.country = data["country"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["buildingNumber"] = this.buildingNumber;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        return data; 
    }
}

export interface IAddress {
    /** Gets or Sets Street */
    street?: string | undefined;
    /** Gets or Sets BuildingNumber */
    buildingNumber?: string | undefined;
    /** Gets or Sets City */
    city?: string | undefined;
    /** Gets or Sets PostalCode */
    postalCode?: string | undefined;
    /** Gets or Sets Country - ISO 3166 ALPHA2 country code */
    country: string;
}

/** GeographicLocation */
export class GeographicLocation implements IGeographicLocation {
    /** The Latitude measured in decimal format according to ISO 213 */
    latitude!: string;
    /** The longitude measured in decimal format according to ISO 213 */
    longitude!: string;

    constructor(data?: IGeographicLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
        }
    }

    static fromJS(data: any): GeographicLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeographicLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }
}

/** GeographicLocation */
export interface IGeographicLocation {
    /** The Latitude measured in decimal format according to ISO 213 */
    latitude: string;
    /** The longitude measured in decimal format according to ISO 213 */
    longitude: string;
}

export class OpeningTimeInfo implements IOpeningTimeInfo {
    /** Day of the week */
    openingDay!: OpeningTimeInfoOpeningDay;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    openingTime!: string;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    closingTime!: string;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    unavailableStartTime?: string | undefined;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    unavailableFinishTime?: string | undefined;

    constructor(data?: IOpeningTimeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openingDay = data["openingDay"];
            this.openingTime = data["openingTime"];
            this.closingTime = data["closingTime"];
            this.unavailableStartTime = data["unavailableStartTime"];
            this.unavailableFinishTime = data["unavailableFinishTime"];
        }
    }

    static fromJS(data: any): OpeningTimeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OpeningTimeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openingDay"] = this.openingDay;
        data["openingTime"] = this.openingTime;
        data["closingTime"] = this.closingTime;
        data["unavailableStartTime"] = this.unavailableStartTime;
        data["unavailableFinishTime"] = this.unavailableFinishTime;
        return data; 
    }
}

export interface IOpeningTimeInfo {
    /** Day of the week */
    openingDay: OpeningTimeInfoOpeningDay;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    openingTime: string;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    closingTime: string;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    unavailableStartTime?: string | undefined;
    /** ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm */
    unavailableFinishTime?: string | undefined;
}

/** Planned branch closure */
export class PlannedBranchClosure implements IPlannedBranchClosure {
    /** Date when a branch is due to close temporarily or permanently */
    startDate?: string | undefined;
    /** Date when a branch is due to re-open following temporary closure */
    endDate?: string | undefined;

    constructor(data?: IPlannedBranchClosure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"];
            this.endDate = data["endDate"];
        }
    }

    static fromJS(data: any): PlannedBranchClosure {
        data = typeof data === 'object' ? data : {};
        let result = new PlannedBranchClosure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        return data; 
    }
}

/** Planned branch closure */
export interface IPlannedBranchClosure {
    /** Date when a branch is due to close temporarily or permanently */
    startDate?: string | undefined;
    /** Date when a branch is due to re-open following temporary closure */
    endDate?: string | undefined;
}

/** ParentOrganisation */
export class ParentOrganisation implements IParentOrganisation {
    /** The LEI ID of the organisation */
    lei?: string | undefined;
    /** The BIC from the organisation */
    bic?: string | undefined;
    /** Organisation Name */
    organisationName!: OrganisationName;

    constructor(data?: IParentOrganisation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organisationName = new OrganisationName();
        }
    }

    init(data?: any) {
        if (data) {
            this.lei = data["lei"];
            this.bic = data["bic"];
            this.organisationName = data["organisationName"] ? OrganisationName.fromJS(data["organisationName"]) : new OrganisationName();
        }
    }

    static fromJS(data: any): ParentOrganisation {
        data = typeof data === 'object' ? data : {};
        let result = new ParentOrganisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lei"] = this.lei;
        data["bic"] = this.bic;
        data["organisationName"] = this.organisationName ? this.organisationName.toJSON() : <any>undefined;
        return data; 
    }
}

/** ParentOrganisation */
export interface IParentOrganisation {
    /** The LEI ID of the organisation */
    lei?: string | undefined;
    /** The BIC from the organisation */
    bic?: string | undefined;
    /** Organisation Name */
    organisationName: OrganisationName;
}

/** Brand Info */
export class Brand implements IBrand {
    /** The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights 
including patents, designs, trademarks and copyright. (Code: UK or EU only) */
    trademarkIPOCode!: BrandTrademarkIPOCode;
    /** The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted */
    trademarkID!: string;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trademarkIPOCode = data["trademarkIPOCode"];
            this.trademarkID = data["trademarkID"];
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trademarkIPOCode"] = this.trademarkIPOCode;
        data["trademarkID"] = this.trademarkID;
        return data; 
    }
}

/** Brand Info */
export interface IBrand {
    /** The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights 
including patents, designs, trademarks and copyright. (Code: UK or EU only) */
    trademarkIPOCode: BrandTrademarkIPOCode;
    /** The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted */
    trademarkID: string;
}

/** OrganisationName */
export class OrganisationName implements IOrganisationName {
    /** Legal Name of the organisation */
    legalName!: string;
    /** Distinctive Title of the organisation */
    distinctiveTitle!: string;

    constructor(data?: IOrganisationName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.distinctiveTitle = data["distinctiveTitle"];
        }
    }

    static fromJS(data: any): OrganisationName {
        data = typeof data === 'object' ? data : {};
        let result = new OrganisationName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["distinctiveTitle"] = this.distinctiveTitle;
        return data; 
    }
}

/** OrganisationName */
export interface IOrganisationName {
    /** Legal Name of the organisation */
    legalName: string;
    /** Distinctive Title of the organisation */
    distinctiveTitle: string;
}

/** ATM */
export class ATM implements IATM {
    /** Organisation */
    organisation!: Organisation;
    /** Unique and unambiguous identification of a retail branch of a financial institution */
    branchIdentification?: string | undefined;
    /** ATM terminal device identification for the acquirer and the issuer */
    atmid!: string;
    /** Indicates the environment of the ATM */
    locationCategory?: ATMLocationCategory | undefined;
    /** Site identifying code, where ATM is located */
    siteID?: string | undefined;
    /** Site identifying name, where ATM is located */
    siteName?: string | undefined;
    /** Postal Address */
    address!: Address;
    /** Geographic Coordinates */
    geographicLocation!: GeographicLocation;
    /** Information about the accessibility */
    accessibilityTypes?: AccessibilityTypes[] | undefined;
    /** Languages that the ATM supports */
    supportedLanguages!: string[];
    /** Information about ATM services */
    atmServices!: AtmServices[];
    /** ATM Service Description */
    additionalATMServices?: string[] | undefined;
    /** Defines currency type available for dispense */
    currency!: string[];
    /** Minimum currency denominations usually available */
    minimumValueDispensed?: ATMMinimumValueDispensed | undefined;

    constructor(data?: IATM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organisation = new Organisation();
            this.address = new Address();
            this.geographicLocation = new GeographicLocation();
            this.supportedLanguages = [];
            this.atmServices = [];
            this.currency = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.organisation = data["organisation"] ? Organisation.fromJS(data["organisation"]) : new Organisation();
            this.branchIdentification = data["branchIdentification"];
            this.atmid = data["atmid"];
            this.locationCategory = data["locationCategory"];
            this.siteID = data["siteID"];
            this.siteName = data["siteName"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.geographicLocation = data["geographicLocation"] ? GeographicLocation.fromJS(data["geographicLocation"]) : new GeographicLocation();
            if (data["accessibilityTypes"] && data["accessibilityTypes"].constructor === Array) {
                this.accessibilityTypes = [] as any;
                for (let item of data["accessibilityTypes"])
                    this.accessibilityTypes!.push(item);
            }
            if (data["supportedLanguages"] && data["supportedLanguages"].constructor === Array) {
                this.supportedLanguages = [] as any;
                for (let item of data["supportedLanguages"])
                    this.supportedLanguages!.push(item);
            }
            if (data["atmServices"] && data["atmServices"].constructor === Array) {
                this.atmServices = [] as any;
                for (let item of data["atmServices"])
                    this.atmServices!.push(item);
            }
            if (data["additionalATMServices"] && data["additionalATMServices"].constructor === Array) {
                this.additionalATMServices = [] as any;
                for (let item of data["additionalATMServices"])
                    this.additionalATMServices!.push(item);
            }
            if (data["currency"] && data["currency"].constructor === Array) {
                this.currency = [] as any;
                for (let item of data["currency"])
                    this.currency!.push(item);
            }
            this.minimumValueDispensed = data["minimumValueDispensed"];
        }
    }

    static fromJS(data: any): ATM {
        data = typeof data === 'object' ? data : {};
        let result = new ATM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["branchIdentification"] = this.branchIdentification;
        data["atmid"] = this.atmid;
        data["locationCategory"] = this.locationCategory;
        data["siteID"] = this.siteID;
        data["siteName"] = this.siteName;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["geographicLocation"] = this.geographicLocation ? this.geographicLocation.toJSON() : <any>undefined;
        if (this.accessibilityTypes && this.accessibilityTypes.constructor === Array) {
            data["accessibilityTypes"] = [];
            for (let item of this.accessibilityTypes)
                data["accessibilityTypes"].push(item);
        }
        if (this.supportedLanguages && this.supportedLanguages.constructor === Array) {
            data["supportedLanguages"] = [];
            for (let item of this.supportedLanguages)
                data["supportedLanguages"].push(item);
        }
        if (this.atmServices && this.atmServices.constructor === Array) {
            data["atmServices"] = [];
            for (let item of this.atmServices)
                data["atmServices"].push(item);
        }
        if (this.additionalATMServices && this.additionalATMServices.constructor === Array) {
            data["additionalATMServices"] = [];
            for (let item of this.additionalATMServices)
                data["additionalATMServices"].push(item);
        }
        if (this.currency && this.currency.constructor === Array) {
            data["currency"] = [];
            for (let item of this.currency)
                data["currency"].push(item);
        }
        data["minimumValueDispensed"] = this.minimumValueDispensed;
        return data; 
    }
}

/** ATM */
export interface IATM {
    /** Organisation */
    organisation: Organisation;
    /** Unique and unambiguous identification of a retail branch of a financial institution */
    branchIdentification?: string | undefined;
    /** ATM terminal device identification for the acquirer and the issuer */
    atmid: string;
    /** Indicates the environment of the ATM */
    locationCategory?: ATMLocationCategory | undefined;
    /** Site identifying code, where ATM is located */
    siteID?: string | undefined;
    /** Site identifying name, where ATM is located */
    siteName?: string | undefined;
    /** Postal Address */
    address: Address;
    /** Geographic Coordinates */
    geographicLocation: GeographicLocation;
    /** Information about the accessibility */
    accessibilityTypes?: AccessibilityTypes[] | undefined;
    /** Languages that the ATM supports */
    supportedLanguages: string[];
    /** Information about ATM services */
    atmServices: AtmServices[];
    /** ATM Service Description */
    additionalATMServices?: string[] | undefined;
    /** Defines currency type available for dispense */
    currency: string[];
    /** Minimum currency denominations usually available */
    minimumValueDispensed?: ATMMinimumValueDispensed | undefined;
}

/** Body of the response for a successful cancel payment request. */
export class PaymentInitiationCancelResponse202 implements IPaymentInitiationCancelResponse202 {
    /** Gets or Sets TransactionStatus */
    transactionStatus!: PaymentInitiationCancelResponse202TransactionStatus;
    /** Gets or Sets ScaMethods */
    scaMethods?: AuthenticationObject[] | undefined;
    /** Gets or Sets ChosenScaMethod */
    chosenScaMethod?: any | undefined;
    /** Gets or Sets ChallengeData */
    challengeData?: ChallengeData | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IPaymentInitiationCancelResponse202) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionStatus = data["transactionStatus"];
            if (data["scaMethods"] && data["scaMethods"].constructor === Array) {
                this.scaMethods = [] as any;
                for (let item of data["scaMethods"])
                    this.scaMethods!.push(AuthenticationObject.fromJS(item));
            }
            this.chosenScaMethod = data["chosenScaMethod"];
            this.challengeData = data["challengeData"] ? ChallengeData.fromJS(data["challengeData"]) : <any>undefined;
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): PaymentInitiationCancelResponse202 {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInitiationCancelResponse202();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        if (this.scaMethods && this.scaMethods.constructor === Array) {
            data["scaMethods"] = [];
            for (let item of this.scaMethods)
                data["scaMethods"].push(item.toJSON());
        }
        data["chosenScaMethod"] = this.chosenScaMethod;
        data["challengeData"] = this.challengeData ? this.challengeData.toJSON() : <any>undefined;
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** Body of the response for a successful cancel payment request. */
export interface IPaymentInitiationCancelResponse202 {
    /** Gets or Sets TransactionStatus */
    transactionStatus: PaymentInitiationCancelResponse202TransactionStatus;
    /** Gets or Sets ScaMethods */
    scaMethods?: AuthenticationObject[] | undefined;
    /** Gets or Sets ChosenScaMethod */
    chosenScaMethod?: any | undefined;
    /** Gets or Sets ChallengeData */
    challengeData?: ChallengeData | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400. */
export class Error400NGPIS implements IError400NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage400PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError400NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage400PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error400NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error400NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400. */
export interface IError400NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage400PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage400PIS implements ITppMessage400PIS {
    /** Gets or Sets Category */
    category!: TppMessage400PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage400PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage400PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage400PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage400PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage400PIS {
    /** Gets or Sets Category */
    category: TppMessage400PISCategory;
    /** Gets or Sets Code */
    code: TppMessage400PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error401NGPIS implements IError401NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError401NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage401PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error401NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error401NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError401NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage401PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage401PIS implements ITppMessage401PIS {
    /** Gets or Sets Category */
    category!: TppMessage401PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage401PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage401PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage401PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage401PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage401PIS {
    /** Gets or Sets Category */
    category: TppMessage401PISCategory;
    /** Gets or Sets Code */
    code: TppMessage401PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export class Error403NGPIS implements IError403NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError403NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage403PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error403NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error403NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403. */
export interface IError403NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage403PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage403PIS implements ITppMessage403PIS {
    /** Gets or Sets Category */
    category!: TppMessage403PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage403PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage403PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage403PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage403PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage403PIS {
    /** Gets or Sets Category */
    category: TppMessage403PISCategory;
    /** Gets or Sets Code */
    code: TppMessage403PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export class Error404NGPIS implements IError404NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError404NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage404PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error404NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error404NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404. */
export interface IError404NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage404PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage404PIS implements ITppMessage404PIS {
    /** Gets or Sets Category */
    category!: TppMessage404PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage404PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage404PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage404PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage404PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage404PIS {
    /** Gets or Sets Category */
    category: TppMessage404PISCategory;
    /** Gets or Sets Code */
    code: TppMessage404PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error405NGPISCANC implements IError405NGPISCANC {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PISCANC[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError405NGPISCANC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage405PISCANC.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error405NGPISCANC {
        data = typeof data === 'object' ? data : {};
        let result = new Error405NGPISCANC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError405NGPISCANC {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PISCANC[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage405PISCANC implements ITppMessage405PISCANC {
    /** Gets or Sets Category */
    category!: TppMessage405PISCANCCategory;
    /** Gets or Sets Code */
    code!: TppMessage405PISCANCCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage405PISCANC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage405PISCANC {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage405PISCANC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage405PISCANC {
    /** Gets or Sets Category */
    category: TppMessage405PISCANCCategory;
    /** Gets or Sets Code */
    code: TppMessage405PISCANCCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export class Error409NGPIS implements IError409NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError409NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage409PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error409NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error409NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409. */
export interface IError409NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage409PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage409PIS implements ITppMessage409PIS {
    /** Gets or Sets Category */
    category!: TppMessage409PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage409PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage409PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage409PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage409PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage409PIS {
    /** Gets or Sets Category */
    category: TppMessage409PISCategory;
    /** Gets or Sets Code */
    code: TppMessage409PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export class Error405NGPIS implements IError405NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;

    constructor(data?: IError405NGPIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tppMessages"] && data["tppMessages"].constructor === Array) {
                this.tppMessages = [] as any;
                for (let item of data["tppMessages"])
                    this.tppMessages!.push(TppMessage405PIS.fromJS(item));
            }
            if (data["_links"]) {
                this._links = {} as any;
                for (let key in data["_links"]) {
                    if (data["_links"].hasOwnProperty(key))
                        this._links![key] = data["_links"][key] ? HrefType.fromJS(data["_links"][key]) : new HrefType();
                }
            }
        }
    }

    static fromJS(data: any): Error405NGPIS {
        data = typeof data === 'object' ? data : {};
        let result = new Error405NGPIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tppMessages && this.tppMessages.constructor === Array) {
            data["tppMessages"] = [];
            for (let item of this.tppMessages)
                data["tppMessages"].push(item.toJSON());
        }
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    data["_links"][key] = this._links[key];
            }
        }
        return data; 
    }
}

/** NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401. */
export interface IError405NGPIS {
    /** Gets or Sets TppMessages */
    tppMessages?: TppMessage405PIS[] | undefined;
    /** Gets or Sets Links */
    _links?: { [key: string] : HrefType; } | undefined;
}

export class TppMessage405PIS implements ITppMessage405PIS {
    /** Gets or Sets Category */
    category!: TppMessage405PISCategory;
    /** Gets or Sets Code */
    code!: TppMessage405PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;

    constructor(data?: ITppMessage405PIS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.code = data["code"];
            this.path = data["path"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TppMessage405PIS {
        data = typeof data === 'object' ? data : {};
        let result = new TppMessage405PIS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["code"] = this.code;
        data["path"] = this.path;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITppMessage405PIS {
    /** Gets or Sets Category */
    category: TppMessage405PISCategory;
    /** Gets or Sets Code */
    code: TppMessage405PISCode;
    /** Gets or Sets Path */
    path?: string | undefined;
    /** Gets or Sets Text */
    text?: any | undefined;
}

/** Body of the response for a successful payment initiation status request in case of an JSON based endpoint. */
export class PaymentInitiationStatusResponse200Json implements IPaymentInitiationStatusResponse200Json {
    /** Gets or Sets TransactionStatus */
    transactionStatus!: PaymentInitiationStatusResponse200JsonTransactionStatus;

    constructor(data?: IPaymentInitiationStatusResponse200Json) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionStatus = data["transactionStatus"];
        }
    }

    static fromJS(data: any): PaymentInitiationStatusResponse200Json {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInitiationStatusResponse200Json();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        return data; 
    }
}

/** Body of the response for a successful payment initiation status request in case of an JSON based endpoint. */
export interface IPaymentInitiationStatusResponse200Json {
    /** Gets or Sets TransactionStatus */
    transactionStatus: PaymentInitiationStatusResponse200JsonTransactionStatus;
}

export enum TppMessage400AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage400AISCode {
    FORMATERROREnum = "FORMATERROREnum", 
    PARAMETERNOTCONSISTENTEnum = "PARAMETERNOTCONSISTENTEnum", 
    PARAMETERNOTSUPPORTEDEnum = "PARAMETERNOTSUPPORTEDEnum", 
    SERVICEINVALIDEnum = "SERVICEINVALIDEnum", 
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    RESOURCEEXPIREDEnum = "RESOURCEEXPIREDEnum", 
    RESOURCEBLOCKEDEnum = "RESOURCEBLOCKEDEnum", 
    TIMESTAMPINVALIDEnum = "TIMESTAMPINVALIDEnum", 
    PERIODINVALIDEnum = "PERIODINVALIDEnum", 
    SCAMETHODUNKNOWNEnum = "SCAMETHODUNKNOWNEnum", 
    CONSENTUNKNOWNEnum = "CONSENTUNKNOWNEnum", 
    SESSIONSNOTSUPPORTEDEnum = "SESSIONSNOTSUPPORTEDEnum", 
}

export enum TppMessage401AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage401AISCode {
    CERTIFICATEINVALIDEnum = "CERTIFICATEINVALIDEnum", 
    CERTIFICATEEXPIREDEnum = "CERTIFICATEEXPIREDEnum", 
    CERTIFICATEBLOCKEDEnum = "CERTIFICATEBLOCKEDEnum", 
    CERTIFICATEREVOKEEnum = "CERTIFICATEREVOKEEnum", 
    CERTIFICATEMISSINGEnum = "CERTIFICATEMISSINGEnum", 
    SIGNATUREINVALIDEnum = "SIGNATUREINVALIDEnum", 
    SIGNATUREMISSINGEnum = "SIGNATUREMISSINGEnum", 
    CORPORATEIDINVALIDEnum = "CORPORATEIDINVALIDEnum", 
    PSUCREDENTIALSINVALIDEnum = "PSUCREDENTIALSINVALIDEnum", 
    CONSENTINVALIDEnum = "CONSENTINVALIDEnum", 
    CONSENTEXPIREDEnum = "CONSENTEXPIREDEnum", 
    TOKENUNKNOWNEnum = "TOKENUNKNOWNEnum", 
    TOKENINVALIDEnum = "TOKENINVALIDEnum", 
    TOKENEXPIREDEnum = "TOKENEXPIREDEnum", 
}

export enum TppMessage403AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage403AISCode {
    CONSENTUNKNOWNEnum = "CONSENTUNKNOWNEnum", 
    SERVICEBLOCKEDEnum = "SERVICEBLOCKEDEnum", 
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    RESOURCEEXPIREDEnum = "RESOURCEEXPIREDEnum", 
}

export enum TppMessage404AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage404AISCode {
    UNKNOWNEnum = "UNKNOWNEnum", 
}

export enum TppMessage405AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage405AISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum TppMessage406AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage406AISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum TppMessage409AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage409AISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum TppMessage429AISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage429AISCode {
    EXCEEDEDEnum = "EXCEEDEDEnum", 
}

export enum StartScaprocessResponseScaStatus {
    ReceivedEnum = "ReceivedEnum", 
    PsuIdentifiedEnum = "PsuIdentifiedEnum", 
    PsuAuthenticatedEnum = "PsuAuthenticatedEnum", 
    ScaMethodSelectedEnum = "ScaMethodSelectedEnum", 
    StartedEnum = "StartedEnum", 
    FinalisedEnum = "FinalisedEnum", 
    FailedEnum = "FailedEnum", 
    ExemptedEnum = "ExemptedEnum", 
}

export enum AuthenticationObjectAuthenticationType {
    SMSOTPEnum = "SMSOTPEnum", 
    CHIPOTPEnum = "CHIPOTPEnum", 
    PHOTOOTPEnum = "PHOTOOTPEnum", 
    PUSHOTPEnum = "PUSHOTPEnum", 
}

export enum ChallengeDataOtpFormat {
    CHARACTERS = "CHARACTERS", 
    INTEGER = "INTEGER", 
}

export enum ConsentInformationResponse200JsonConsentStatus {
    ReceivedEnum = "ReceivedEnum", 
    RejectedEnum = "RejectedEnum", 
    ValidEnum = "ValidEnum", 
    RevokedByPsuEnum = "RevokedByPsuEnum", 
    ExpiredEnum = "ExpiredEnum", 
    TerminatedByTppEnum = "TerminatedByTppEnum", 
}

export enum AccountAccessAvailableAccounts {
    ALLACCOUNTS = "ALLACCOUNTS", 
    ALLACCOUNTSWITHBALANCES = "ALLACCOUNTSWITHBALANCES", 
}

export enum AccountAccessAllPsd2 {
    ALLACCOUNTS = "ALLACCOUNTS", 
}

export enum ScaStatusResponseScaStatus {
    ReceivedEnum = "ReceivedEnum", 
    PsuIdentifiedEnum = "PsuIdentifiedEnum", 
    PsuAuthenticatedEnum = "PsuAuthenticatedEnum", 
    ScaMethodSelectedEnum = "ScaMethodSelectedEnum", 
    StartedEnum = "StartedEnum", 
    FinalisedEnum = "FinalisedEnum", 
    FailedEnum = "FailedEnum", 
    ExemptedEnum = "ExemptedEnum", 
}

export enum ConsentStatusResponse200ConsentStatus {
    ReceivedEnum = "ReceivedEnum", 
    RejectedEnum = "RejectedEnum", 
    ValidEnum = "ValidEnum", 
    RevokedByPsuEnum = "RevokedByPsuEnum", 
    ExpiredEnum = "ExpiredEnum", 
    TerminatedByTppEnum = "TerminatedByTppEnum", 
}

export enum TransactionDetailsPurposeCode {
    BKDFEnum = "BKDFEnum", 
    BKFEEnum = "BKFEEnum", 
    BKFMEnum = "BKFMEnum", 
    BKIPEnum = "BKIPEnum", 
    BKPPEnum = "BKPPEnum", 
    CBLKEnum = "CBLKEnum", 
    CDCBEnum = "CDCBEnum", 
    CDCDEnum = "CDCDEnum", 
    CDCSEnum = "CDCSEnum", 
    CDDPEnum = "CDDPEnum", 
    CDOCEnum = "CDOCEnum", 
    CDQCEnum = "CDQCEnum", 
    ETUPEnum = "ETUPEnum", 
    FCOLEnum = "FCOLEnum", 
    MTUPEnum = "MTUPEnum", 
    ACCTEnum = "ACCTEnum", 
    CASHEnum = "CASHEnum", 
    COLLEnum = "COLLEnum", 
    CSDBEnum = "CSDBEnum", 
    DEPTEnum = "DEPTEnum", 
    INTCEnum = "INTCEnum", 
    LIMAEnum = "LIMAEnum", 
    NETTEnum = "NETTEnum", 
    BFWDEnum = "BFWDEnum", 
    CCIREnum = "CCIREnum", 
    CCPCEnum = "CCPCEnum", 
    CCPMEnum = "CCPMEnum", 
    CCSMEnum = "CCSMEnum", 
    CRDSEnum = "CRDSEnum", 
    CRPREnum = "CRPREnum", 
    CRSPEnum = "CRSPEnum", 
    CRTLEnum = "CRTLEnum", 
    EQPTEnum = "EQPTEnum", 
    EQUSEnum = "EQUSEnum", 
    EXPTEnum = "EXPTEnum", 
    EXTDEnum = "EXTDEnum", 
    FIXIEnum = "FIXIEnum", 
    FWBCEnum = "FWBCEnum", 
    FWCCEnum = "FWCCEnum", 
    FWSBEnum = "FWSBEnum", 
    FWSCEnum = "FWSCEnum", 
    MARGEnum = "MARGEnum", 
    MBSBEnum = "MBSBEnum", 
    MBSCEnum = "MBSCEnum", 
    MGCCEnum = "MGCCEnum", 
    MGSCEnum = "MGSCEnum", 
    OCCCEnum = "OCCCEnum", 
    OPBCEnum = "OPBCEnum", 
    OPCCEnum = "OPCCEnum", 
    OPSBEnum = "OPSBEnum", 
    OPSCEnum = "OPSCEnum", 
    OPTNEnum = "OPTNEnum", 
    OTCDEnum = "OTCDEnum", 
    REPOEnum = "REPOEnum", 
    RPBCEnum = "RPBCEnum", 
    RPCCEnum = "RPCCEnum", 
    RPSBEnum = "RPSBEnum", 
    RPSCEnum = "RPSCEnum", 
    RVPOEnum = "RVPOEnum", 
    SBSCEnum = "SBSCEnum", 
    SCIEEnum = "SCIEEnum", 
    SCIREnum = "SCIREnum", 
    SCRPEnum = "SCRPEnum", 
    SHBCEnum = "SHBCEnum", 
    SHCCEnum = "SHCCEnum", 
    SHSLEnum = "SHSLEnum", 
    SLEBEnum = "SLEBEnum", 
    SLOAEnum = "SLOAEnum", 
    SWBCEnum = "SWBCEnum", 
    SWCCEnum = "SWCCEnum", 
    SWPTEnum = "SWPTEnum", 
    SWSBEnum = "SWSBEnum", 
    SWSCEnum = "SWSCEnum", 
    TBASEnum = "TBASEnum", 
    TBBCEnum = "TBBCEnum", 
    TBCCEnum = "TBCCEnum", 
    TRCPEnum = "TRCPEnum", 
    AGRTEnum = "AGRTEnum", 
    ARENEnum = "ARENEnum", 
    BEXPEnum = "BEXPEnum", 
    BOCEEnum = "BOCEEnum", 
    COMCEnum = "COMCEnum", 
    CPYREnum = "CPYREnum", 
    GDDSEnum = "GDDSEnum", 
    GDSVEnum = "GDSVEnum", 
    GSCBEnum = "GSCBEnum", 
    LICFEnum = "LICFEnum", 
    MP2BEnum = "MP2BEnum", 
    POPEEnum = "POPEEnum", 
    ROYAEnum = "ROYAEnum", 
    SCVEEnum = "SCVEEnum", 
    SERVEnum = "SERVEnum", 
    SUBSEnum = "SUBSEnum", 
    SUPPEnum = "SUPPEnum", 
    TRADEnum = "TRADEnum", 
    CHAREnum = "CHAREnum", 
    COMTEnum = "COMTEnum", 
    MP2PEnum = "MP2PEnum", 
    ECPGEnum = "ECPGEnum", 
    ECPREnum = "ECPREnum", 
    ECPUEnum = "ECPUEnum", 
    EPAYEnum = "EPAYEnum", 
    CLPREnum = "CLPREnum", 
    COMPEnum = "COMPEnum", 
    DBTCEnum = "DBTCEnum", 
    GOVIEnum = "GOVIEnum", 
    HLRPEnum = "HLRPEnum", 
    HLSTEnum = "HLSTEnum", 
    INPCEnum = "INPCEnum", 
    INPREnum = "INPREnum", 
    INSCEnum = "INSCEnum", 
    INSUEnum = "INSUEnum", 
    INTEEnum = "INTEEnum", 
    LBRIEnum = "LBRIEnum", 
    LIFIEnum = "LIFIEnum", 
    LOANEnum = "LOANEnum", 
    LOAREnum = "LOAREnum", 
    PENOEnum = "PENOEnum", 
    PPTIEnum = "PPTIEnum", 
    RELGEnum = "RELGEnum", 
    RINPEnum = "RINPEnum", 
    TRFDEnum = "TRFDEnum", 
    FORWEnum = "FORWEnum", 
    FXNTEnum = "FXNTEnum", 
    ADMGEnum = "ADMGEnum", 
    ADVAEnum = "ADVAEnum", 
    BCDMEnum = "BCDMEnum", 
    BCFGEnum = "BCFGEnum", 
    BLDMEnum = "BLDMEnum", 
    BNETEnum = "BNETEnum", 
    CBFFEnum = "CBFFEnum", 
    CBFREnum = "CBFREnum", 
    CCRDEnum = "CCRDEnum", 
    CDBLEnum = "CDBLEnum", 
    CFEEEnum = "CFEEEnum", 
    CGDDEnum = "CGDDEnum", 
    CORTEnum = "CORTEnum", 
    COSTEnum = "COSTEnum", 
    CPKCEnum = "CPKCEnum", 
    DCRDEnum = "DCRDEnum", 
    DSMTEnum = "DSMTEnum", 
    DVPMEnum = "DVPMEnum", 
    EDUCEnum = "EDUCEnum", 
    FACTEnum = "FACTEnum", 
    FANDEnum = "FANDEnum", 
    FCPMEnum = "FCPMEnum", 
    FEESEnum = "FEESEnum", 
    GOVTEnum = "GOVTEnum", 
    ICCPEnum = "ICCPEnum", 
    IDCPEnum = "IDCPEnum", 
    IHRPEnum = "IHRPEnum", 
    INSMEnum = "INSMEnum", 
    IVPTEnum = "IVPTEnum", 
    MCDMEnum = "MCDMEnum", 
    MCFGEnum = "MCFGEnum", 
    MSVCEnum = "MSVCEnum", 
    NOWSEnum = "NOWSEnum", 
    OCDMEnum = "OCDMEnum", 
    OCFGEnum = "OCFGEnum", 
    OFEEEnum = "OFEEEnum", 
    OTHREnum = "OTHREnum", 
    PADDEnum = "PADDEnum", 
    PTSPEnum = "PTSPEnum", 
    RCKEEnum = "RCKEEnum", 
    RCPTEnum = "RCPTEnum", 
    REBTEnum = "REBTEnum", 
    REFUEnum = "REFUEnum", 
    RENTEnum = "RENTEnum", 
    REODEnum = "REODEnum", 
    RIMBEnum = "RIMBEnum", 
    RPNTEnum = "RPNTEnum", 
    RRBNEnum = "RRBNEnum", 
    RVPMEnum = "RVPMEnum", 
    SLPIEnum = "SLPIEnum", 
    SPLTEnum = "SPLTEnum", 
    STDYEnum = "STDYEnum", 
    TBANEnum = "TBANEnum", 
    TBILEnum = "TBILEnum", 
    TCSCEnum = "TCSCEnum", 
    TELIEnum = "TELIEnum", 
    TMPGEnum = "TMPGEnum", 
    TPRIEnum = "TPRIEnum", 
    TPRPEnum = "TPRPEnum", 
    TRNCEnum = "TRNCEnum", 
    TRVCEnum = "TRVCEnum", 
    WEBIEnum = "WEBIEnum", 
    ANNIEnum = "ANNIEnum", 
    CAFIEnum = "CAFIEnum", 
    CFDIEnum = "CFDIEnum", 
    CMDTEnum = "CMDTEnum", 
    DERIEnum = "DERIEnum", 
    DIVDEnum = "DIVDEnum", 
    FREXEnum = "FREXEnum", 
    HEDGEnum = "HEDGEnum", 
    INVSEnum = "INVSEnum", 
    PRMEEnum = "PRMEEnum", 
    SAVGEnum = "SAVGEnum", 
    SECUEnum = "SECUEnum", 
    SEPIEnum = "SEPIEnum", 
    TREAEnum = "TREAEnum", 
    UNITEnum = "UNITEnum", 
    FNETEnum = "FNETEnum", 
    FUTREnum = "FUTREnum", 
    ANTSEnum = "ANTSEnum", 
    CVCFEnum = "CVCFEnum", 
    DMEQEnum = "DMEQEnum", 
    DNTSEnum = "DNTSEnum", 
    HLTCEnum = "HLTCEnum", 
    HLTIEnum = "HLTIEnum", 
    HSPCEnum = "HSPCEnum", 
    ICRFEnum = "ICRFEnum", 
    LTCFEnum = "LTCFEnum", 
    MAFCEnum = "MAFCEnum", 
    MARFEnum = "MARFEnum", 
    MDCSEnum = "MDCSEnum", 
    VIEWEnum = "VIEWEnum", 
    CDEPEnum = "CDEPEnum", 
    SWFPEnum = "SWFPEnum", 
    SWPPEnum = "SWPPEnum", 
    SWRSEnum = "SWRSEnum", 
    SWUFEnum = "SWUFEnum", 
    ADCSEnum = "ADCSEnum", 
    AEMPEnum = "AEMPEnum", 
    ALLWEnum = "ALLWEnum", 
    ALMYEnum = "ALMYEnum", 
    BBSCEnum = "BBSCEnum", 
    BECHEnum = "BECHEnum", 
    BENEEnum = "BENEEnum", 
    BONUEnum = "BONUEnum", 
    CCHDEnum = "CCHDEnum", 
    COMMEnum = "COMMEnum", 
    CSLPEnum = "CSLPEnum", 
    GFRPEnum = "GFRPEnum", 
    GVEAEnum = "GVEAEnum", 
    GVEBEnum = "GVEBEnum", 
    GVECEnum = "GVECEnum", 
    GVEDEnum = "GVEDEnum", 
    GWLTEnum = "GWLTEnum", 
    HRECEnum = "HRECEnum", 
    PAYREnum = "PAYREnum", 
    PEFCEnum = "PEFCEnum", 
    PENSEnum = "PENSEnum", 
    PRCPEnum = "PRCPEnum", 
    RHBSEnum = "RHBSEnum", 
    SALAEnum = "SALAEnum", 
    SSBEEnum = "SSBEEnum", 
    LBINEnum = "LBINEnum", 
    LCOLEnum = "LCOLEnum", 
    LFEEEnum = "LFEEEnum", 
    LMEQEnum = "LMEQEnum", 
    LMFIEnum = "LMFIEnum", 
    LMRKEnum = "LMRKEnum", 
    LREBEnum = "LREBEnum", 
    LREVEnum = "LREVEnum", 
    LSFLEnum = "LSFLEnum", 
    ESTXEnum = "ESTXEnum", 
    FWLVEnum = "FWLVEnum", 
    GSTXEnum = "GSTXEnum", 
    HSTXEnum = "HSTXEnum", 
    INTXEnum = "INTXEnum", 
    NITXEnum = "NITXEnum", 
    PTXPEnum = "PTXPEnum", 
    RDTXEnum = "RDTXEnum", 
    TAXSEnum = "TAXSEnum", 
    VATXEnum = "VATXEnum", 
    WHLDEnum = "WHLDEnum", 
    TAXREnum = "TAXREnum", 
    B112Enum = "B112Enum", 
    BR12Enum = "BR12Enum", 
    TLRFEnum = "TLRFEnum", 
    TLRREnum = "TLRREnum", 
    AIRBEnum = "AIRBEnum", 
    BUSBEnum = "BUSBEnum", 
    FERBEnum = "FERBEnum", 
    RLWYEnum = "RLWYEnum", 
    TRPTEnum = "TRPTEnum", 
    CBTVEnum = "CBTVEnum", 
    ELECEnum = "ELECEnum", 
    ENRGEnum = "ENRGEnum", 
    GASBEnum = "GASBEnum", 
    NWCHEnum = "NWCHEnum", 
    NWCMEnum = "NWCMEnum", 
    OTLCEnum = "OTLCEnum", 
    PHONEnum = "PHONEnum", 
    UBILEnum = "UBILEnum", 
    WTEREnum = "WTEREnum", 
}

export enum BalanceType {
    ClosingBookedEnum = "ClosingBookedEnum", 
    ExpectedEnum = "ExpectedEnum", 
    AuthorisedEnum = "AuthorisedEnum", 
    OpeningBookedEnum = "OpeningBookedEnum", 
    InterimAvailableEnum = "InterimAvailableEnum", 
    InterimBookedEnum = "InterimBookedEnum", 
    ForwardAvailableEnum = "ForwardAvailableEnum", 
    NonInvoicedEnum = "NonInvoicedEnum", 
}

export enum AccountDetailsStatus {
    EnabledEnum = "EnabledEnum", 
    DeletedEnum = "DeletedEnum", 
    BlockedEnum = "BlockedEnum", 
}

export enum AccountDetailsUsage {
    PRIV = "PRIV", 
    ORGA = "ORGA", 
}

export enum TppMessage401PIISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage401PIISCode {
    CERTIFICATEINVALIDEnum = "CERTIFICATEINVALIDEnum", 
    CERTIFICATEEXPIREDEnum = "CERTIFICATEEXPIREDEnum", 
    CERTIFICATEBLOCKEDEnum = "CERTIFICATEBLOCKEDEnum", 
    CERTIFICATEREVOKEEnum = "CERTIFICATEREVOKEEnum", 
    CERTIFICATEMISSINGEnum = "CERTIFICATEMISSINGEnum", 
    SIGNATUREINVALIDEnum = "SIGNATUREINVALIDEnum", 
    SIGNATUREMISSINGEnum = "SIGNATUREMISSINGEnum", 
    CORPORATEIDINVALIDEnum = "CORPORATEIDINVALIDEnum", 
    PSUCREDENTIALSINVALIDEnum = "PSUCREDENTIALSINVALIDEnum", 
    CONSENTINVALIDEnum = "CONSENTINVALIDEnum", 
    CONSENTEXPIREDEnum = "CONSENTEXPIREDEnum", 
    TOKENUNKNOWNEnum = "TOKENUNKNOWNEnum", 
    TOKENINVALIDEnum = "TOKENINVALIDEnum", 
    TOKENEXPIREDEnum = "TOKENEXPIREDEnum", 
}

export enum TppMessage403PIISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage403PIISCode {
    CONSENTUNKNOWNEnum = "CONSENTUNKNOWNEnum", 
    SERVICEBLOCKEDEnum = "SERVICEBLOCKEDEnum", 
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    RESOURCEEXPIREDEnum = "RESOURCEEXPIREDEnum", 
}

export enum TppMessage404PIISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage404PIISCode {
    UNKNOWNEnum = "UNKNOWNEnum", 
}

export enum TppMessage405PIISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage405PIISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum TppMessage409PIISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage409PIISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum BranchType {
    Physical = "physical", 
    Mobile = "mobile", 
}

export enum BranchAccessibilityTypes {
    AudioCashMachine = "audioCashMachine", 
    AutomaticDoors = "automaticDoors", 
    ChairAccess = "chairAccess", 
    DriveThru = "driveThru", 
    ExternalRamp = "externalRamp", 
    InductionLoop = "inductionLoop", 
    InternalRamp = "internalRamp", 
    LevelAccess = "levelAccess", 
    LowerLevelCounter = "lowerLevelCounter", 
    WheelchairAccess = "wheelchairAccess", 
}

export enum BranchSelfServeServiceName {
    AccountVerificationService = "accountVerificationService", 
    AssistedServiceCounter = "assistedServiceCounter", 
    BusinessDepositTerminal = "businessDepositTerminal", 
    CashChequeDepositMachineCoin = "cashChequeDepositMachineCoin", 
    CashChequeDepositMachineNoCoin = "cashChequeDepositMachineNoCoin", 
    ExternalAtmAudio = "externalAtmAudio", 
    ExternalAtmNoAudio = "externalAtmNoAudio", 
    ExternalQuickServicePoint = "externalQuickServicePoint", 
    InternalAtmAudio = "internalAtmAudio", 
    InternalAtmNoAudio = "internalAtmNoAudio", 
    InternalQuickServicePoint = "internalQuickServicePoint", 
    LodgementDevice = "lodgementDevice", 
    OnlineBankingPoint = "onlineBankingPoint", 
    QuickDeposit = "quickDeposit", 
    SaturdayCounterService = "saturdayCounterService", 
    SelfServiceAccountOpening = "selfServiceAccountOpening", 
    StatementPrinter = "statementPrinter", 
}

export enum BranchMediatedServiceName {
    BureauDeChange = "bureauDeChange", 
    BusinessCounter = "businessCounter", 
    CardIssuanceFacility = "cardIssuanceFacility", 
    CounterServices = "counterServices", 
    DriveThru = "driveThru", 
    MortgageAdvisor = "mortgageAdvisor", 
    NightSafe = "nightSafe", 
    OnDemandCurrency = "onDemandCurrency", 
    PremierCounter = "premierCounter", 
    VideoBanking = "videoBanking", 
    WheelChairAccess = "wheelChairAccess", 
}

export enum BranchFacilitiesName {
    BusinessITSupport = "businessITSupport", 
    CollectionLockers = "collectionLockers", 
    MeetingRooms = "meetingRooms", 
    Parking = "parking", 
    Wifi = "wifi", 
}

export enum CustomerSegment {
    Business = "business", 
    Corporate = "corporate", 
    Personal = "personal", 
    Premier = "premier", 
    Private = "private", 
    Select = "select", 
    SME = "sME", 
    Wealth = "wealth", 
}

export enum OpeningTimeInfoOpeningDay {
    Monday = "monday", 
    Tuesday = "tuesday", 
    Wednesday = "wednesday", 
    Thursday = "thursday", 
    Friday = "friday", 
    Saturday = "saturday", 
    Sunday = "sunday", 
    Public_and_Bank_Holiday = "public_and_Bank_Holiday", 
}

export enum BrandTrademarkIPOCode {
    UK = "uK", 
    EU = "eU", 
}

export enum ATMLocationCategory {
    Airport = "airport", 
    BankSpecialisedOutlet = "bankSpecialisedOutlet", 
    BranchExternal = "branchExternal", 
    BranchInternal = "branchInternal", 
    BranchLobby = "branchLobby", 
    BureauDeChange = "bureauDeChange", 
    CoachStation = "coachStation", 
    CommercialSpaceInternal = "commercialSpaceInternal", 
    ConvenienceStore = "convenienceStore", 
    ExhibitionCentre = "exhibitionCentre", 
    FactoryOrOffice = "factoryOrOffice", 
    FillingStation = "fillingStation", 
    FinancialInstitution = "financialInstitution", 
    GovernmentOffice = "governmentOffice", 
    Hospital = "hospital", 
    Hotel = "hotel", 
    KioskPod = "kioskPod", 
    LeisureCentre = "leisureCentre", 
    PleasurePark = "pleasurePark", 
    PublicHouse = "publicHouse", 
    RailwayStation = "railwayStation", 
    RemoteUnit = "remoteUnit", 
    RetailerDepartmentStore = "retailerDepartmentStore", 
    RetailerOutlet = "retailerOutlet", 
    SeaportTerminal = "seaportTerminal", 
    ServiceStation = "serviceStation", 
    ShoppingCentreExternal = "shoppingCentreExternal", 
    ShoppingCentreInternal = "shoppingCentreInternal", 
    StorageDepot = "storageDepot", 
    SupermarketExternal = "supermarketExternal", 
    SupermarketInternal = "supermarketInternal", 
    UndergroundRailwayStation = "undergroundRailwayStation", 
    UniversityOrCollege = "universityOrCollege", 
}

export enum AccessibilityTypes {
    AudioCashMachine = "audioCashMachine", 
    AutomaticDoors = "automaticDoors", 
    ChairAccess = "chairAccess", 
    DriveThru = "driveThru", 
    ExternalRamp = "externalRamp", 
    InductionLoop = "inductionLoop", 
    InternalRamp = "internalRamp", 
    LevelAccess = "levelAccess", 
    LowerLevelCounter = "lowerLevelCounter", 
    WheelchairAccess = "wheelchairAccess", 
}

export enum AtmServices {
    Balance = "balance", 
    BillPayments = "billPayments", 
    CashDeposits = "cashDeposits", 
    CashWithdrawal = "cashWithdrawal", 
    CharityDonation = "charityDonation", 
    ChequeBookRequest = "chequeBookRequest", 
    ChequeDeposits = "chequeDeposits", 
    FastCash = "fastCash", 
    MiniStatement = "miniStatement", 
    MobileBankingRegistration = "mobileBankingRegistration", 
    MobilePaymentRegistration = "mobilePaymentRegistration", 
    MobilePhoneTopUp = "mobilePhoneTopUp", 
    OrderStatement = "orderStatement", 
    PINActivation = "pINActivation", 
    PINChange = "pINChange", 
}

export enum ATMMinimumValueDispensed {
    ΜΙΝ_5 = "μΙΝ_5", 
    ΜΙΝ_10 = "μΙΝ_10", 
    ΜΙΝ_20 = "μΙΝ_20", 
    ΜΙΝ_50 = "μΙΝ_50", 
    ΜΙΝ_100 = "μΙΝ_100", 
}

export enum PaymentInitiationCancelResponse202TransactionStatus {
    ACCCEnum = "ACCCEnum", 
    ACCPEnum = "ACCPEnum", 
    ACSCEnum = "ACSCEnum", 
    ACSPEnum = "ACSPEnum", 
    ACTCEnum = "ACTCEnum", 
    ACWCEnum = "ACWCEnum", 
    ACWPEnum = "ACWPEnum", 
    RCVDEnum = "RCVDEnum", 
    PDNGEnum = "PDNGEnum", 
    RJCTEnum = "RJCTEnum", 
    CANCEnum = "CANCEnum", 
    ACFCEnum = "ACFCEnum", 
    PATCEnum = "PATCEnum", 
    PARTEnum = "PARTEnum", 
}

export enum TppMessage400PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage400PISCode {
    FORMATERROREnum = "FORMATERROREnum", 
    PARAMETERNOTCONSISTENTEnum = "PARAMETERNOTCONSISTENTEnum", 
    PARAMETERNOTSUPPORTEDEnum = "PARAMETERNOTSUPPORTEDEnum", 
    SERVICEINVALIDEnum = "SERVICEINVALIDEnum", 
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    RESOURCEEXPIREDEnum = "RESOURCEEXPIREDEnum", 
    RESOURCEBLOCKEDEnum = "RESOURCEBLOCKEDEnum", 
    TIMESTAMPINVALIDEnum = "TIMESTAMPINVALIDEnum", 
    PERIODINVALIDEnum = "PERIODINVALIDEnum", 
    SCAMETHODUNKNOWNEnum = "SCAMETHODUNKNOWNEnum", 
    CONSENTUNKNOWNEnum = "CONSENTUNKNOWNEnum", 
    PAYMENTFAILEDEnum = "PAYMENTFAILEDEnum", 
    EXECUTIONDATEINVALIDEnum = "EXECUTIONDATEINVALIDEnum", 
}

export enum TppMessage401PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage401PISCode {
    CERTIFICATEINVALIDEnum = "CERTIFICATEINVALIDEnum", 
    CERTIFICATEEXPIREDEnum = "CERTIFICATEEXPIREDEnum", 
    CERTIFICATEBLOCKEDEnum = "CERTIFICATEBLOCKEDEnum", 
    CERTIFICATEREVOKEEnum = "CERTIFICATEREVOKEEnum", 
    CERTIFICATEMISSINGEnum = "CERTIFICATEMISSINGEnum", 
    SIGNATUREINVALIDEnum = "SIGNATUREINVALIDEnum", 
    SIGNATUREMISSINGEnum = "SIGNATUREMISSINGEnum", 
    CORPORATEIDINVALIDEnum = "CORPORATEIDINVALIDEnum", 
    PSUCREDENTIALSINVALIDEnum = "PSUCREDENTIALSINVALIDEnum", 
    CONSENTINVALIDEnum = "CONSENTINVALIDEnum", 
    CONSENTEXPIREDEnum = "CONSENTEXPIREDEnum", 
    TOKENUNKNOWNEnum = "TOKENUNKNOWNEnum", 
    TOKENINVALIDEnum = "TOKENINVALIDEnum", 
    TOKENEXPIREDEnum = "TOKENEXPIREDEnum", 
    REQUIREDKIDMISSINGEnum = "REQUIREDKIDMISSINGEnum", 
}

export enum TppMessage403PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage403PISCode {
    CONSENTUNKNOWNEnum = "CONSENTUNKNOWNEnum", 
    SERVICEBLOCKEDEnum = "SERVICEBLOCKEDEnum", 
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    RESOURCEEXPIREDEnum = "RESOURCEEXPIREDEnum", 
    PRODUCTINVALIDEnum = "PRODUCTINVALIDEnum", 
}

export enum TppMessage404PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage404PISCode {
    RESOURCEUNKNOWNEnum = "RESOURCEUNKNOWNEnum", 
    PRODUCTUNKNOWNEnum = "PRODUCTUNKNOWNEnum", 
}

export enum TppMessage405PISCANCCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage405PISCANCCode {
    CANCELLATIONINVALIDEnum = "CANCELLATIONINVALIDEnum", 
    SERVICEINVALIDEnum = "SERVICEINVALIDEnum", 
}

export enum TppMessage409PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage409PISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum TppMessage405PISCategory {
    ERROREnum = "ERROREnum", 
    WARNINGEnum = "WARNINGEnum", 
}

export enum TppMessage405PISCode {
    INVALIDEnum = "INVALIDEnum", 
}

export enum PaymentInitiationStatusResponse200JsonTransactionStatus {
    ACCCEnum = "ACCCEnum", 
    ACCPEnum = "ACCPEnum", 
    ACSCEnum = "ACSCEnum", 
    ACSPEnum = "ACSPEnum", 
    ACTCEnum = "ACTCEnum", 
    ACWCEnum = "ACWCEnum", 
    ACWPEnum = "ACWPEnum", 
    RCVDEnum = "RCVDEnum", 
    PDNGEnum = "PDNGEnum", 
    RJCTEnum = "RJCTEnum", 
    CANCEnum = "CANCEnum", 
    ACFCEnum = "ACFCEnum", 
    PATCEnum = "PATCEnum", 
    PARTEnum = "PARTEnum", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}

}