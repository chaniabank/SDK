//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

namespace ChaniaBank
{
    #pragma warning disable

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiClient 
    {
        private string _baseUrl = "/psd2";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public ApiClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Get Consent Authorisation Sub-Resources Request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Authorisations> GetConsentAuthorisationAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetConsentAuthorisationAsync(consentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Consent Authorisation Sub-Resources Request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<Authorisations> GetConsentAuthorisationAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}/authorisations");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Authorisations); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Authorisations>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Authorisations);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Start the authorisation process for a consent</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StartScaprocessResponse> StartConsentAuthorisationAsync(System.Guid xRequestID, string consentId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return StartConsentAuthorisationAsync(xRequestID, consentId, body, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, tPPRedirectPreferred, tPPRedirectURI, tPPNokRedirectURI, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Start the authorisation process for a consent</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<StartScaprocessResponse> StartConsentAuthorisationAsync(System.Guid xRequestID, string consentId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}/authorisations");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectPreferred", ConvertToString(tPPRedirectPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectURI", ConvertToString(tPPRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPNokRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPNokRedirectURI", ConvertToString(tPPNokRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(StartScaprocessResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<StartScaprocessResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StartScaprocessResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Consent Request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ConsentInformationResponse200Json> GetConsentInformationAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetConsentInformationAsync(consentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Consent Request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ConsentInformationResponse200Json> GetConsentInformationAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ConsentInformationResponse200Json); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ConsentInformationResponse200Json>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ConsentInformationResponse200Json);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read the SCA status of the consent authorisation.</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ScaStatusResponse> GetConsentScaStatusAsync(string consentId, string authorisationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetConsentScaStatusAsync(consentId, authorisationId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read the SCA status of the consent authorisation.</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ScaStatusResponse> GetConsentScaStatusAsync(string consentId, string authorisationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            if (authorisationId == null)
                throw new System.ArgumentNullException("authorisationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}/authorisations/{authorisationId}");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{authorisationId}", System.Uri.EscapeDataString(ConvertToString(authorisationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ScaStatusResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ScaStatusResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ScaStatusResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update PSU Data for consents</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdateConsentsPsuDataAsync(System.Guid xRequestID, string consentId, string authorisationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return UpdateConsentsPsuDataAsync(xRequestID, consentId, authorisationId, body, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Update PSU Data for consents</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task UpdateConsentsPsuDataAsync(System.Guid xRequestID, string consentId, string authorisationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            if (authorisationId == null)
                throw new System.ArgumentNullException("authorisationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}/authorisations/{authorisationId}");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{authorisationId}", System.Uri.EscapeDataString(ConvertToString(authorisationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Consent status request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ConsentStatusResponse200> GetConsentStatusAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetConsentStatusAsync(consentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Consent status request</summary>
        /// <param name="consentId">ID of the corresponding consent object as returned by an Account Information Consent Request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ConsentStatusResponse200> GetConsentStatusAsync(string consentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (consentId == null)
                throw new System.ArgumentNullException("consentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/consents/{consentId}/status");
            urlBuilder_.Replace("{consentId}", System.Uri.EscapeDataString(ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ConsentStatusResponse200); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ConsentStatusResponse200>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ConsentStatusResponse200);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read Transaction Details</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="resourceId">This identification is given by the attribute resourceId of the corresponding entry of a transaction list.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TransactionDetails> GetTransactionDetailsAsync(string accountId, string resourceId, System.Guid xRequestID, string consentId, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetTransactionDetailsAsync(accountId, resourceId, xRequestID, consentId, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read Transaction Details</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="resourceId">This identification is given by the attribute resourceId of the corresponding entry of a transaction list.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<TransactionDetails> GetTransactionDetailsAsync(string accountId, string resourceId, System.Guid xRequestID, string consentId, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            if (resourceId == null)
                throw new System.ArgumentNullException("resourceId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/accounts/{accountId}/transactions/{resourceId}");
            urlBuilder_.Replace("{accountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourceId}", System.Uri.EscapeDataString(ConvertToString(resourceId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (consentId == null)
                        throw new System.ArgumentNullException("consentId");
                    request_.Headers.TryAddWithoutValidation("consentId", ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(TransactionDetails); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<TransactionDetails>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(TransactionDetails);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read transaction list of an account</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="bookingStatus">Permitted codes are    * \"booked\",   * \"pending\" and    * \"both\" \"booked\" shall be supported by the ASPSP. To support the \"pending\" and \"both\" feature is optional for the ASPSP,  Error code if not supported in the online banking frontend</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="dateFrom">Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.</param>
        /// <param name="dateTo">End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.</param>
        /// <param name="entryReferenceFrom">This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \"dateFrom\" and \"dateTo\" might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider.</param>
        /// <param name="deltaList">This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider</param>
        /// <param name="withBalance">If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TransactionsResponse200Json> GetTransactionListAsync(string accountId, string bookingStatus, System.Guid xRequestID, string consentId, System.DateTimeOffset? dateFrom, System.DateTimeOffset? dateTo, string entryReferenceFrom, bool? deltaList, bool? withBalance, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetTransactionListAsync(accountId, bookingStatus, xRequestID, consentId, dateFrom, dateTo, entryReferenceFrom, deltaList, withBalance, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read transaction list of an account</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="bookingStatus">Permitted codes are    * \"booked\",   * \"pending\" and    * \"both\" \"booked\" shall be supported by the ASPSP. To support the \"pending\" and \"both\" feature is optional for the ASPSP,  Error code if not supported in the online banking frontend</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="dateFrom">Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.</param>
        /// <param name="dateTo">End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP.</param>
        /// <param name="entryReferenceFrom">This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \"dateFrom\" and \"dateTo\" might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider.</param>
        /// <param name="deltaList">This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider</param>
        /// <param name="withBalance">If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<TransactionsResponse200Json> GetTransactionListAsync(string accountId, string bookingStatus, System.Guid xRequestID, string consentId, System.DateTimeOffset? dateFrom, System.DateTimeOffset? dateTo, string entryReferenceFrom, bool? deltaList, bool? withBalance, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            if (bookingStatus == null)
                throw new System.ArgumentNullException("bookingStatus");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/accounts/{accountId}/transactions?");
            urlBuilder_.Replace("{accountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append("bookingStatus=").Append(System.Uri.EscapeDataString(ConvertToString(bookingStatus, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (dateFrom != null) 
            {
                urlBuilder_.Append("dateFrom=").Append(System.Uri.EscapeDataString(dateFrom.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dateTo != null) 
            {
                urlBuilder_.Append("dateTo=").Append(System.Uri.EscapeDataString(dateTo.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (entryReferenceFrom != null) 
            {
                urlBuilder_.Append("entryReferenceFrom=").Append(System.Uri.EscapeDataString(ConvertToString(entryReferenceFrom, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deltaList != null) 
            {
                urlBuilder_.Append("deltaList=").Append(System.Uri.EscapeDataString(ConvertToString(deltaList, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withBalance != null) 
            {
                urlBuilder_.Append("withBalance=").Append(System.Uri.EscapeDataString(ConvertToString(withBalance, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (consentId == null)
                        throw new System.ArgumentNullException("consentId");
                    request_.Headers.TryAddWithoutValidation("consentId", ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(TransactionsResponse200Json); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<TransactionsResponse200Json>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(TransactionsResponse200Json);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read Account Details</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="withBalance">If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AccountDetails> ReadAccountDetailsAsync(string accountId, System.Guid xRequestID, string consentId, bool? withBalance, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return ReadAccountDetailsAsync(accountId, xRequestID, consentId, withBalance, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read Account Details</summary>
        /// <param name="accountId">This identification is denoting the addressed account.  The accountId is retrieved by using a \"Read Account List\" call.  The accountId is the \"id\" attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="withBalance">If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<AccountDetails> ReadAccountDetailsAsync(string accountId, System.Guid xRequestID, string consentId, bool? withBalance, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/accounts/{accountId}?");
            urlBuilder_.Replace("{accountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
            if (withBalance != null) 
            {
                urlBuilder_.Append("withBalance=").Append(System.Uri.EscapeDataString(ConvertToString(withBalance, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (consentId == null)
                        throw new System.ArgumentNullException("consentId");
                    request_.Headers.TryAddWithoutValidation("consentId", ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AccountDetails); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AccountDetails>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(AccountDetails);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Confirmation of Funds Request</summary>
        /// <param name="body">Request body for a confirmation of funds request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ConfirmationOfFundsResponse200> CheckAvailabilityOfFundsAsync(ConfirmationOfFunds body, System.Guid xRequestID, string consentId, string digest, string signature, byte[] tPPSignatureCertificate)
        {
            return CheckAvailabilityOfFundsAsync(body, xRequestID, consentId, digest, signature, tPPSignatureCertificate, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Confirmation of Funds Request</summary>
        /// <param name="body">Request body for a confirmation of funds request.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="consentId">This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ConfirmationOfFundsResponse200> CheckAvailabilityOfFundsAsync(ConfirmationOfFunds body, System.Guid xRequestID, string consentId, string digest, string signature, byte[] tPPSignatureCertificate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/funds-confirmations");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (consentId != null)
                        request_.Headers.TryAddWithoutValidation("consentId", ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ConfirmationOfFundsResponse200); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ConfirmationOfFundsResponse200>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ConfirmationOfFundsResponse200);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Branches information</summary>
        /// <param name="if_Modified_Since">Used for conditional request, to retrieve data only if modified since a given date</param>
        /// <param name="if_None_Match">Used for conditional request, to retrieve data only if the given Etag value does not match</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Branch>> GetBranchesAsync(string if_Modified_Since, string if_None_Match)
        {
            return GetBranchesAsync(if_Modified_Since, if_None_Match, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Branches information</summary>
        /// <param name="if_Modified_Since">Used for conditional request, to retrieve data only if modified since a given date</param>
        /// <param name="if_None_Match">Used for conditional request, to retrieve data only if the given Etag value does not match</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Branch>> GetBranchesAsync(string if_Modified_Since, string if_None_Match, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/opendata/branches?");
            if (if_Modified_Since != null) 
            {
                urlBuilder_.Append("if_Modified_Since=").Append(System.Uri.EscapeDataString(ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (if_None_Match != null) 
            {
                urlBuilder_.Append("if_None_Match=").Append(System.Uri.EscapeDataString(ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(System.Collections.Generic.ICollection<Branch>); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.ICollection<Branch>>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<Branch>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Successful response with a list of `ATM` data</summary>
        /// <param name="if_Modified_Since">Used for conditional request, to retrieve data only if modified since a given date</param>
        /// <param name="if_None_Match">Used for conditional request, to retrieve data only if the given Etag value does not match</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ATM>> GetATMsAsync(string if_Modified_Since, string if_None_Match)
        {
            return GetATMsAsync(if_Modified_Since, if_None_Match, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Successful response with a list of `ATM` data</summary>
        /// <param name="if_Modified_Since">Used for conditional request, to retrieve data only if modified since a given date</param>
        /// <param name="if_None_Match">Used for conditional request, to retrieve data only if the given Etag value does not match</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ATM>> GetATMsAsync(string if_Modified_Since, string if_None_Match, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/opendata/atm?");
            if (if_Modified_Since != null) 
            {
                urlBuilder_.Append("if_Modified_Since=").Append(System.Uri.EscapeDataString(ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (if_None_Match != null) 
            {
                urlBuilder_.Append("if_None_Match=").Append(System.Uri.EscapeDataString(ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(System.Collections.Generic.ICollection<ATM>); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.ICollection<ATM>>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGAIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGAIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGAIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGAIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGAIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error406NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error406NGAIS>("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGAIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error429NGAIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error429NGAIS>("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<ATM>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Payment Information</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task GetPaymentInformationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentInformationAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Payment Information</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task GetPaymentInformationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Payment Cancellation Request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Received</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PaymentInitiationCancelResponse202> CancelPaymentAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return CancelPaymentAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Payment Cancellation Request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Received</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PaymentInitiationCancelResponse202> CancelPaymentAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(PaymentInitiationCancelResponse202); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PaymentInitiationCancelResponse202>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPISCANC); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPISCANC>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPISCANC>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "204") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("No Content", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(PaymentInitiationCancelResponse202);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read the SCA status of the payment cancellation's authorisation.</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="cancellationId">Identification for cancellation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ScaStatusResponse> GetPaymentCancellationScaStatusAsync(string paymentService, string paymentProduct, string paymentId, string cancellationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentCancellationScaStatusAsync(paymentService, paymentProduct, paymentId, cancellationId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read the SCA status of the payment cancellation's authorisation.</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="cancellationId">Identification for cancellation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ScaStatusResponse> GetPaymentCancellationScaStatusAsync(string paymentService, string paymentProduct, string paymentId, string cancellationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            if (cancellationId == null)
                throw new System.ArgumentNullException("cancellationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations/{cancellationId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{cancellationId}", System.Uri.EscapeDataString(ConvertToString(cancellationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ScaStatusResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ScaStatusResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ScaStatusResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update PSU Data for payment initiation cancellation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="cancellationId">Identification for cancellation resource.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdatePaymentCancellationPsuDataAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string cancellationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return UpdatePaymentCancellationPsuDataAsync(xRequestID, paymentService, paymentProduct, paymentId, cancellationId, body, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Update PSU Data for payment initiation cancellation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="cancellationId">Identification for cancellation resource.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task UpdatePaymentCancellationPsuDataAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string cancellationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            if (cancellationId == null)
                throw new System.ArgumentNullException("cancellationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations/{cancellationId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{cancellationId}", System.Uri.EscapeDataString(ConvertToString(cancellationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Payment Initiation Authorisation Sub-Resources Request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Authorisations> GetPaymentInitiationAuthorisationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentInitiationAuthorisationAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Payment Initiation Authorisation Sub-Resources Request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<Authorisations> GetPaymentInitiationAuthorisationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Authorisations); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Authorisations>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Authorisations);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Start the authorisation process for a payment initiation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StartScaprocessResponse> StartPaymentAuthorisationAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string body, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return StartPaymentAuthorisationAsync(xRequestID, paymentService, paymentProduct, paymentId, body, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, tPPRedirectPreferred, tPPRedirectURI, tPPNokRedirectURI, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Start the authorisation process for a payment initiation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<StartScaprocessResponse> StartPaymentAuthorisationAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string body, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectPreferred", ConvertToString(tPPRedirectPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectURI", ConvertToString(tPPRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPNokRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPNokRedirectURI", ConvertToString(tPPNokRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(StartScaprocessResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<StartScaprocessResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StartScaprocessResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources.</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPaymentInitiationCancellationAuthorisationInformationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentInitiationCancellationAuthorisationInformationAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources.</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> GetPaymentInitiationCancellationAuthorisationInformationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(System.Collections.Generic.ICollection<string>); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.ICollection<string>>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Start the authorisation process for the cancellation of the addressed payment</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<StartScaprocessResponse> StartPaymentInitiationCancellationAuthorisationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return StartPaymentInitiationCancellationAuthorisationAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, tPPRedirectPreferred, tPPRedirectURI, tPPNokRedirectURI, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Start the authorisation process for the cancellation of the addressed payment</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>Created</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<StartScaprocessResponse> StartPaymentInitiationCancellationAuthorisationAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/cancellation-authorisations");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectPreferred", ConvertToString(tPPRedirectPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectURI", ConvertToString(tPPRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPNokRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPNokRedirectURI", ConvertToString(tPPNokRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(StartScaprocessResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<StartScaprocessResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(StartScaprocessResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Read the SCA Status of the payment authorisation</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ScaStatusResponse> GetPaymentInitiationScaStatusAsync(string paymentService, string paymentProduct, string paymentId, string authorisationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentInitiationScaStatusAsync(paymentService, paymentProduct, paymentId, authorisationId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Read the SCA Status of the payment authorisation</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<ScaStatusResponse> GetPaymentInitiationScaStatusAsync(string paymentService, string paymentProduct, string paymentId, string authorisationId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            if (authorisationId == null)
                throw new System.ArgumentNullException("authorisationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations/{authorisationId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{authorisationId}", System.Uri.EscapeDataString(ConvertToString(authorisationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(ScaStatusResponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<ScaStatusResponse>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ScaStatusResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update PSU data for payment initiation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdatePaymentPsuDataAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string authorisationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return UpdatePaymentPsuDataAsync(xRequestID, paymentService, paymentProduct, paymentId, authorisationId, body, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Update PSU data for payment initiation</summary>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="authorisationId">Resource identification of the related SCA.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task UpdatePaymentPsuDataAsync(System.Guid xRequestID, string paymentService, string paymentProduct, string paymentId, string authorisationId, string body, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            if (authorisationId == null)
                throw new System.ArgumentNullException("authorisationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/authorisations/{authorisationId}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{authorisationId}", System.Uri.EscapeDataString(ConvertToString(authorisationId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Payment initiation status request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PaymentInitiationStatusResponse200Json> GetPaymentInitiationStatusAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return GetPaymentInitiationStatusAsync(paymentService, paymentProduct, paymentId, xRequestID, digest, signature, tPPSignatureCertificate, pSUIPAddress, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Payment initiation status request</summary>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="paymentId">Resource identification of the generated payment initiation resource.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>OK</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<PaymentInitiationStatusResponse200Json> GetPaymentInitiationStatusAsync(string paymentService, string paymentProduct, string paymentId, System.Guid xRequestID, string digest, string signature, byte[] tPPSignatureCertificate, string pSUIPAddress, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}/{paymentId}/status");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(PaymentInitiationStatusResponse200Json); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<PaymentInitiationStatusResponse200Json>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(PaymentInitiationStatusResponse200Json);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Payment initiation request</summary>
        /// <param name="body">JSON request body for a payment inition request message 
        ///             There are the following paymentProducts supported:
        ///             * "sepa-credit-transfers" with JSON-Body
        ///             * "instant-sepa-credit-transfers" with JSON-Body
        ///             * "target-2-payments" with JSON-Body
        ///             * "cross-border-credit-transfers" with JSON-Body
        ///             * "pain.001-sepa-credit-transfers" with XML pain.001.001.03 body for SCT scheme
        ///             * "pain.001-instant-sepa-credit-transfers" with XML pain.001.001.03 body for SCT INST scheme
        ///             * "pain.001-target-2-payments" with pain.001 body. 
        ///             Only country specific schemes are currently available
        ///             * "pain.001-cross-border-credit-transfers" with pain.001 body. 
        ///             Only country specific schemes are currently available
        ///             There are the following paymentServices supported:
        ///             * "payments"
        ///             * "periodic-payments"
        ///             * "bulk-paments"
        ///             All optional, conditional and predefined but not yet used fields are defined.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="consentId">This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="tPPExplicitAuthorisationPreferred">If it equals \"true\", the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \"false\" or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket.</param>
        /// <param name="tPPRejectionNoFundsPreferred">If it equals \"true\" then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \"false\" then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>CREATED</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task InitiatePaymentAsync(string body, System.Guid xRequestID, string pSUIPAddress, string paymentService, string paymentProduct, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string consentId, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string tPPExplicitAuthorisationPreferred, string tPPRejectionNoFundsPreferred, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation)
        {
            return InitiatePaymentAsync(body, xRequestID, pSUIPAddress, paymentService, paymentProduct, digest, signature, tPPSignatureCertificate, pSU_ID, pSUIDType, pSUCorporateID, pSUCorporateIDType, consentId, tPPRedirectPreferred, tPPRedirectURI, tPPNokRedirectURI, tPPExplicitAuthorisationPreferred, tPPRejectionNoFundsPreferred, pSUIPPort, pSUAccept, pSUAcceptCharset, pSUAcceptEncoding, pSUAcceptLanguage, pSUUserAgent, pSUHttpMethod, pSUDeviceID, pSUGeoLocation, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Payment initiation request</summary>
        /// <param name="body">JSON request body for a payment inition request message 
        ///             There are the following paymentProducts supported:
        ///             * "sepa-credit-transfers" with JSON-Body
        ///             * "instant-sepa-credit-transfers" with JSON-Body
        ///             * "target-2-payments" with JSON-Body
        ///             * "cross-border-credit-transfers" with JSON-Body
        ///             * "pain.001-sepa-credit-transfers" with XML pain.001.001.03 body for SCT scheme
        ///             * "pain.001-instant-sepa-credit-transfers" with XML pain.001.001.03 body for SCT INST scheme
        ///             * "pain.001-target-2-payments" with pain.001 body. 
        ///             Only country specific schemes are currently available
        ///             * "pain.001-cross-border-credit-transfers" with pain.001 body. 
        ///             Only country specific schemes are currently available
        ///             There are the following paymentServices supported:
        ///             * "payments"
        ///             * "periodic-payments"
        ///             * "bulk-paments"
        ///             All optional, conditional and predefined but not yet used fields are defined.</param>
        /// <param name="xRequestID">ID of the request, unique to the call, as determined by the initiating party.</param>
        /// <param name="pSUIPAddress">The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.</param>
        /// <param name="paymentService">Payment service:  Possible values are: * payments * bulk-payments * periodic-payments</param>
        /// <param name="paymentProduct">The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants.</param>
        /// <param name="digest">Is contained if and only if the \"Signature\" element is contained in the header of the request.</param>
        /// <param name="signature">A signature of the request by the TPP on application level. This might be mandated by ASPSP.</param>
        /// <param name="tPPSignatureCertificate">The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained.</param>
        /// <param name="pSU_ID">Client ID of the PSU in the ASPSP client interface. Might be mandated in the ASPSP's documentation. Is not contained if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session.</param>
        /// <param name="pSUIDType">Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.</param>
        /// <param name="pSUCorporateID">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="pSUCorporateIDType">Might be mandated in the ASPSP's documentation. Only used in a corporate context.</param>
        /// <param name="consentId">This data element may be contained, if the payment initiation transaction is part of a session, i.e. combined AIS/PIS service. This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation.</param>
        /// <param name="tPPRedirectPreferred">If it equals \"true\", the TPP prefers a redirect over an embedded SCA approach. If it equals \"false\", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU.</param>
        /// <param name="tPPRedirectURI">URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \"true\". It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification.</param>
        /// <param name="tPPNokRedirectURI">If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP.</param>
        /// <param name="tPPExplicitAuthorisationPreferred">If it equals \"true\", the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \"false\" or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket.</param>
        /// <param name="tPPRejectionNoFundsPreferred">If it equals \"true\" then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \"false\" then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP.</param>
        /// <param name="pSUIPPort">The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.</param>
        /// <param name="pSUAccept">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptCharset">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptEncoding">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUAcceptLanguage">The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.</param>
        /// <param name="pSUUserAgent">The forwarded Agent header field of the HTTP request between PSU and TPP, if available.</param>
        /// <param name="pSUHttpMethod">HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE</param>
        /// <param name="pSUDeviceID">UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.</param>
        /// <param name="pSUGeoLocation">The forwarded Geo Location of the corresponding http request between PSU and TPP if available.</param>
        /// <returns>CREATED</returns>
        /// <exception cref="AppException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task InitiatePaymentAsync(string body, System.Guid xRequestID, string pSUIPAddress, string paymentService, string paymentProduct, string digest, string signature, byte[] tPPSignatureCertificate, string pSU_ID, string pSUIDType, string pSUCorporateID, string pSUCorporateIDType, string consentId, string tPPRedirectPreferred, string tPPRedirectURI, string tPPNokRedirectURI, string tPPExplicitAuthorisationPreferred, string tPPRejectionNoFundsPreferred, string pSUIPPort, string pSUAccept, string pSUAcceptCharset, string pSUAcceptEncoding, string pSUAcceptLanguage, string pSUUserAgent, string pSUHttpMethod, System.Guid? pSUDeviceID, string pSUGeoLocation, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentService == null)
                throw new System.ArgumentNullException("paymentService");
    
            if (paymentProduct == null)
                throw new System.ArgumentNullException("paymentProduct");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/{paymentService}/{paymentProduct}");
            urlBuilder_.Replace("{paymentService}", System.Uri.EscapeDataString(ConvertToString(paymentService, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentProduct}", System.Uri.EscapeDataString(ConvertToString(paymentProduct, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (xRequestID == null)
                        throw new System.ArgumentNullException("xRequestID");
                    request_.Headers.TryAddWithoutValidation("xRequestID", ConvertToString(xRequestID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPAddress == null)
                        throw new System.ArgumentNullException("pSUIPAddress");
                    request_.Headers.TryAddWithoutValidation("pSUIPAddress", ConvertToString(pSUIPAddress, System.Globalization.CultureInfo.InvariantCulture));
                    if (digest != null)
                        request_.Headers.TryAddWithoutValidation("digest", ConvertToString(digest, System.Globalization.CultureInfo.InvariantCulture));
                    if (signature != null)
                        request_.Headers.TryAddWithoutValidation("signature", ConvertToString(signature, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPSignatureCertificate != null)
                        request_.Headers.TryAddWithoutValidation("tPPSignatureCertificate", ConvertToString(tPPSignatureCertificate, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSU_ID != null)
                        request_.Headers.TryAddWithoutValidation("PSU_ID", ConvertToString(pSU_ID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUIDType", ConvertToString(pSUIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateID != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateID", ConvertToString(pSUCorporateID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUCorporateIDType != null)
                        request_.Headers.TryAddWithoutValidation("pSUCorporateIDType", ConvertToString(pSUCorporateIDType, System.Globalization.CultureInfo.InvariantCulture));
                    if (consentId != null)
                        request_.Headers.TryAddWithoutValidation("consentId", ConvertToString(consentId, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectPreferred", ConvertToString(tPPRedirectPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPRedirectURI", ConvertToString(tPPRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPNokRedirectURI != null)
                        request_.Headers.TryAddWithoutValidation("tPPNokRedirectURI", ConvertToString(tPPNokRedirectURI, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPExplicitAuthorisationPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPExplicitAuthorisationPreferred", ConvertToString(tPPExplicitAuthorisationPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (tPPRejectionNoFundsPreferred != null)
                        request_.Headers.TryAddWithoutValidation("tPPRejectionNoFundsPreferred", ConvertToString(tPPRejectionNoFundsPreferred, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUIPPort != null)
                        request_.Headers.TryAddWithoutValidation("pSUIPPort", ConvertToString(pSUIPPort, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAccept != null)
                        request_.Headers.TryAddWithoutValidation("pSUAccept", ConvertToString(pSUAccept, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptCharset != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptCharset", ConvertToString(pSUAcceptCharset, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptEncoding != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptEncoding", ConvertToString(pSUAcceptEncoding, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUAcceptLanguage != null)
                        request_.Headers.TryAddWithoutValidation("pSUAcceptLanguage", ConvertToString(pSUAcceptLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUUserAgent != null)
                        request_.Headers.TryAddWithoutValidation("pSUUserAgent", ConvertToString(pSUUserAgent, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUHttpMethod != null)
                        request_.Headers.TryAddWithoutValidation("pSUHttpMethod", ConvertToString(pSUHttpMethod, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUDeviceID != null)
                        request_.Headers.TryAddWithoutValidation("pSUDeviceID", ConvertToString(pSUDeviceID, System.Globalization.CultureInfo.InvariantCulture));
                    if (pSUGeoLocation != null)
                        request_.Headers.TryAddWithoutValidation("pSUGeoLocation", ConvertToString(pSUGeoLocation, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error400NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error400NGPIS>("Bad Request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error401NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error401NGPIS>("Unauthorized", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error403NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error403NGPIS>("Forbidden", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error404NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error404NGPIS>("Not found", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error405NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error405NGPIS>("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Error409NGPIS); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new AppException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new AppException<Error409NGPIS>("Conflict", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "201") 
                        {
                            return;
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "408") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Request Timeout", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Unsupported Media Type", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("Service Unavailable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new AppException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }
    
    

    /// <summary>An array of all authorisationIds</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Authorisations 
    {
        /// <summary>Gets or Sets AuthorisationIds - An array of all authorisationIds</summary>
        [Newtonsoft.Json.JsonProperty("authorisationIds", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> AuthorisationIds { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Authorisations FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Authorisations>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error400NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage400AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error400NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage400AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage400AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage400AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage400AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage400AIS>(data);
        }
    
    }
    
    /// <summary>Link to a resource</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HrefType 
    {
        /// <summary>Gets or Sets Href - Link to a resource</summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static HrefType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HrefType>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error401NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage401AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error401NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage401AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage401AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage401AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error403NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage403AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error403NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage403AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage403AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage403AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error404NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage404AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error404NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage404AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage404AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage404AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error405NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage405AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error405NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage405AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage405AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage405AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 406.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error406NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage406AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error406NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error406NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage406AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage406AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage406AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage406AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage406AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error409NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage409AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error409NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage409AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage409AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage409AIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 429.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error429NGAIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage429AIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error429NGAIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error429NGAIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage429AIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage429AISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage429AISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage429AIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage429AIS>(data);
        }
    
    }
    
    /// <summary>Body of the JSON response for a Start SCA authorisation request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StartScaprocessResponse 
    {
        /// <summary>Gets or Sets ScaStatus</summary>
        [Newtonsoft.Json.JsonProperty("scaStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StartScaprocessResponseScaStatus ScaStatus { get; set; }
    
        /// <summary>Gets or Sets AuthorisationId</summary>
        [Newtonsoft.Json.JsonProperty("authorisationId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorisationId { get; set; }
    
        /// <summary>Gets or Sets ScaMethods</summary>
        [Newtonsoft.Json.JsonProperty("scaMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AuthenticationObject> ScaMethods { get; set; }
    
        /// <summary>Gets or Sets ChosenScaMethod</summary>
        [Newtonsoft.Json.JsonProperty("chosenScaMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ChosenScaMethod { get; set; }
    
        /// <summary>Gets or Sets ChallengeData</summary>
        [Newtonsoft.Json.JsonProperty("challengeData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ChallengeData ChallengeData { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; } = new System.Collections.Generic.Dictionary<string, HrefType>();
    
        /// <summary>Gets or Sets PsuMessage - Text to be displayed to the PSU</summary>
        [Newtonsoft.Json.JsonProperty("psuMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PsuMessage { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static StartScaprocessResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<StartScaprocessResponse>(data);
        }
    
    }
    
    /// <summary>Authentication Object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthenticationObject 
    {
        /// <summary>Gets or Sets AuthenticationType</summary>
        [Newtonsoft.Json.JsonProperty("authenticationType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuthenticationObjectAuthenticationType AuthenticationType { get; set; }
    
        /// <summary>Depending on the \"authenticationType\". This version can be used by differentiating authentication tools used within performing OTP generation in the same authentication type. This version can be referred to in the ASPSP?s documentation.</summary>
        [Newtonsoft.Json.JsonProperty("authenticationVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthenticationVersion { get; set; }
    
        /// <summary>Gets or Sets AuthenticationMethodId - An identification provided by the ASPSP for the later identification of the authentication method selection.</summary>
        [Newtonsoft.Json.JsonProperty("authenticationMethodId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthenticationMethodId { get; set; }
    
        /// <summary>This is the name of the authentication method defined by the PSU in the Online Banking frontend of the ASPSP. Alternatively this could be a description provided by the ASPSP like \"SMS OTP on phone +49160 xxxxx 28\". This name shall be used by the TPP when presenting a list of authentication methods to the PSU, if available.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Detailed information about the SCA method for the PSU.</summary>
        [Newtonsoft.Json.JsonProperty("explanation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Explanation { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AuthenticationObject FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AuthenticationObject>(data);
        }
    
    }
    
    /// <summary>It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA. In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChallengeData 
    {
        /// <summary>PNG data (max. 512 kilobyte) to be displayed to the PSU, Base64 encoding, cp. [RFC4648]. This attribute is used only, when PHOTO_OTP or CHIP_OTP is the selected SCA method.</summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Image { get; set; }
    
        /// <summary>String challenge data</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Data { get; set; }
    
        /// <summary>A link where the ASPSP will provides the challenge image for the TPP.</summary>
        [Newtonsoft.Json.JsonProperty("imageLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImageLink { get; set; }
    
        /// <summary>The maximal length for the OTP to be typed in by the PSU.</summary>
        [Newtonsoft.Json.JsonProperty("otpMaxLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OtpMaxLength { get; set; }
    
        /// <summary>The format type of the OTP to be typed in. The admitted values are \"characters\" or \"integer\".</summary>
        [Newtonsoft.Json.JsonProperty("otpFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ChallengeDataOtpFormat? OtpFormat { get; set; }
    
        /// <summary>Additional explanation for the PSU to explain e.g. fallback mechanism for the chosen SCA method. The TPP is obliged to show this to the PSU.</summary>
        [Newtonsoft.Json.JsonProperty("additionalInformation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AdditionalInformation { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ChallengeData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ChallengeData>(data);
        }
    
    }
    
    /// <summary>Body of the JSON response for a successfull get consent request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsentInformationResponse200Json 
    {
        /// <summary>Gets or Sets Access</summary>
        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AccountAccess Access { get; set; } = new AccountAccess();
    
        /// <summary>Gets or Sets RecurringIndicator</summary>
        [Newtonsoft.Json.JsonProperty("recurringIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object RecurringIndicator { get; set; } = new object();
    
        /// <summary>Gets or Sets ValidUntil</summary>
        [Newtonsoft.Json.JsonProperty("validUntil", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidUntil { get; set; }
    
        /// <summary>Gets or Sets FrequencyPerDay - This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one.</summary>
        [Newtonsoft.Json.JsonProperty("frequencyPerDay", Required = Newtonsoft.Json.Required.Always)]
        public int FrequencyPerDay { get; set; }
    
        /// <summary>Gets or Sets LastActionDate</summary>
        [Newtonsoft.Json.JsonProperty("lastActionDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastActionDate { get; set; }
    
        /// <summary>Gets or Sets ConsentStatus</summary>
        [Newtonsoft.Json.JsonProperty("consentStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConsentInformationResponse200JsonConsentStatus ConsentStatus { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ConsentInformationResponse200Json FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ConsentInformationResponse200Json>(data);
        }
    
    }
    
    /// <summary>Requested access services for a consent.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AccountAccess 
    {
        /// <summary>Is asking for detailed account information.   If the array is empty, the TPP is asking for an accessible account list.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for balances or transactions shall be empty, if used.</summary>
        [Newtonsoft.Json.JsonProperty("accounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountReference> Accounts { get; set; }
    
        /// <summary>Is asking for balances of the addressed accounts.  If the array is empty, the TPP is asking for the balances of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or transactions shall be empty, if used.</summary>
        [Newtonsoft.Json.JsonProperty("balances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountReference> Balances { get; set; }
    
        /// <summary>Is asking for transactions of the addressed accounts.   If the array is empty, the TPP is asking for the transactions of all accessible account lists.  This may be restricted in a PSU/ASPSP authorization dialogue. If the array is empty, also the arrays for accounts or balances shall be empty, if used.</summary>
        [Newtonsoft.Json.JsonProperty("transactions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountReference> Transactions { get; set; }
    
        /// <summary>Optional if supported by API provider.  Only the values \"allAccounts\" or \"allAccountsWithBalances\" is admitted.</summary>
        [Newtonsoft.Json.JsonProperty("availableAccounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountAccessAvailableAccounts? AvailableAccounts { get; set; }
    
        /// <summary>Optional if supported by API provider.  Only the value \"allAccounts\" is admitted.</summary>
        [Newtonsoft.Json.JsonProperty("allPsd2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountAccessAllPsd2? AllPsd2 { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AccountAccess FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AccountAccess>(data);
        }
    
    }
    
    /// <summary>Reference to an account by either   * IBAN, of a payment accounts, or   * BBAN, for payment accounts if there is no IBAN, or    * the Primary Account Number (PAN) of a card, can be tokenised by the ASPSP due to PCI DSS requirements, or   * the Primary Account Number (PAN) of a card in a masked form, or   * an alias to access a payment account via a registered mobile phone number (MSISDN).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AccountReference 
    {
        /// <summary>Gets or Sets Iban</summary>
        [Newtonsoft.Json.JsonProperty("iban", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iban { get; set; }
    
        /// <summary>Gets or Sets Bban</summary>
        [Newtonsoft.Json.JsonProperty("bban", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bban { get; set; }
    
        /// <summary>Gets or Sets Pan</summary>
        [Newtonsoft.Json.JsonProperty("pan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pan { get; set; }
    
        /// <summary>Gets or Sets MaskedPan</summary>
        [Newtonsoft.Json.JsonProperty("maskedPan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MaskedPan { get; set; }
    
        /// <summary>Gets or Sets Msisdn</summary>
        [Newtonsoft.Json.JsonProperty("msisdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Msisdn { get; set; }
    
        /// <summary>Gets or Sets Currency - ISO 4217 Alpha 3 currency code</summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Currency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AccountReference FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AccountReference>(data);
        }
    
    }
    
    /// <summary>Body of the JSON response with SCA Status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ScaStatusResponse 
    {
        /// <summary>Gets or Sets ScaStatus</summary>
        [Newtonsoft.Json.JsonProperty("scaStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ScaStatusResponseScaStatus? ScaStatus { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ScaStatusResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ScaStatusResponse>(data);
        }
    
    }
    
    /// <summary>Body of the JSON response for a successful get status request for a consent.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsentStatusResponse200 
    {
        /// <summary>Gets or Sets ConsentStatus</summary>
        [Newtonsoft.Json.JsonProperty("consentStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConsentStatusResponse200ConsentStatus ConsentStatus { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ConsentStatusResponse200 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ConsentStatusResponse200>(data);
        }
    
    }
    
    /// <summary>Transaction details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransactionDetails 
    {
        /// <summary>the Transaction Id can be used as access-ID in the API, where more details on an transaction is offered.  If this data attribute is provided this shows that the AIS can get access on more details about this  transaction using the GET Transaction Details Request</summary>
        [Newtonsoft.Json.JsonProperty("transactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TransactionId { get; set; }
    
        /// <summary>Is the identification of the transaction as used e.g. for reference for deltafunction on application level.  The same identification as for example used within camt.05x messages.</summary>
        [Newtonsoft.Json.JsonProperty("entryReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EntryReference { get; set; }
    
        /// <summary>Unique end to end identity.</summary>
        [Newtonsoft.Json.JsonProperty("endToEndId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EndToEndId { get; set; }
    
        /// <summary>Identification of Mandates, e.g. a SEPA Mandate ID.</summary>
        [Newtonsoft.Json.JsonProperty("mandateId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MandateId { get; set; }
    
        /// <summary>Identification of a Cheque.</summary>
        [Newtonsoft.Json.JsonProperty("checkId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CheckId { get; set; }
    
        /// <summary>Identification of Creditors, e.g. a SEPA Creditor ID.</summary>
        [Newtonsoft.Json.JsonProperty("creditorId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreditorId { get; set; }
    
        /// <summary>Gets or Sets BookingDate</summary>
        [Newtonsoft.Json.JsonProperty("bookingDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? BookingDate { get; set; }
    
        /// <summary>The Date at which assets become available to the account owner in case of a credit.</summary>
        [Newtonsoft.Json.JsonProperty("valueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValueDate { get; set; }
    
        /// <summary>Gets or Sets TransactionAmount</summary>
        [Newtonsoft.Json.JsonProperty("transactionAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount TransactionAmount { get; set; } = new Amount();
    
        /// <summary>Gets or Sets CurrencyExchange</summary>
        [Newtonsoft.Json.JsonProperty("currencyExchange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ReportExchangeRate> CurrencyExchange { get; set; }
    
        /// <summary>Gets or Sets CreditorName</summary>
        [Newtonsoft.Json.JsonProperty("creditorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreditorName { get; set; }
    
        /// <summary>Gets or Sets CreditorAccount</summary>
        [Newtonsoft.Json.JsonProperty("creditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountReference CreditorAccount { get; set; }
    
        /// <summary>Gets or Sets UltimateCreditor</summary>
        [Newtonsoft.Json.JsonProperty("ultimateCreditor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UltimateCreditor { get; set; }
    
        /// <summary>Gets or Sets DebtorName</summary>
        [Newtonsoft.Json.JsonProperty("debtorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DebtorName { get; set; }
    
        /// <summary>Gets or Sets DebtorAccount</summary>
        [Newtonsoft.Json.JsonProperty("debtorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountReference DebtorAccount { get; set; }
    
        /// <summary>Gets or Sets UltimateDebtor</summary>
        [Newtonsoft.Json.JsonProperty("ultimateDebtor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UltimateDebtor { get; set; }
    
        /// <summary>Gets or Sets RemittanceInformationUnstructured</summary>
        [Newtonsoft.Json.JsonProperty("remittanceInformationUnstructured", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object RemittanceInformationUnstructured { get; set; }
    
        /// <summary>Reference as contained in the structured remittance reference structure (without the surrounding XML structure).  Different from other places the content is containt in plain form not in form of a structered field.</summary>
        [Newtonsoft.Json.JsonProperty("remittanceInformationStructured", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemittanceInformationStructured { get; set; }
    
        /// <summary>Might be used by the ASPSP to transport additional transaction related information to the PSU.</summary>
        [Newtonsoft.Json.JsonProperty("additionalInformation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AdditionalInformation { get; set; }
    
        /// <summary>Gets or Sets PurposeCode</summary>
        [Newtonsoft.Json.JsonProperty("purposeCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TransactionDetailsPurposeCode? PurposeCode { get; set; }
    
        /// <summary>Gets or Sets BankTransactionCode - Bank transaction code as used by the ASPSP and using the sub elements of this structured code defined by ISO 20022.   
        /// This code type is concatenating the three ISO20022 Codes    
        /// * Domain Code,    * Family Code, and    * SubFamiliy Code  by hyphens, 
        /// resulting in �DomainCode�-�FamilyCode�-�SubFamilyCode�.</summary>
        [Newtonsoft.Json.JsonProperty("bankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BankTransactionCode { get; set; }
    
        /// <summary>Gets or Sets ProprietaryBankTransactionCode</summary>
        [Newtonsoft.Json.JsonProperty("proprietaryBankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ProprietaryBankTransactionCode { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TransactionDetails FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TransactionDetails>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Amount 
    {
        /// <summary>Gets or Sets Currency - ISO 4217 Alpha 3 currency code</summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }
    
        /// <summary>Gets or Sets _Amount</summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public double Amount1 { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Amount FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Amount>(data);
        }
    
    }
    
    /// <summary>Exchange Rate</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ReportExchangeRate 
    {
        /// <summary>Gets or Sets SourceCurrency - ISO 4217 Alpha 3 currency code</summary>
        [Newtonsoft.Json.JsonProperty("sourceCurrency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SourceCurrency { get; set; }
    
        /// <summary>Gets or Sets ExchangeRate</summary>
        [Newtonsoft.Json.JsonProperty("exchangeRate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ExchangeRate { get; set; }
    
        /// <summary>Gets or Sets UnitCurrency</summary>
        [Newtonsoft.Json.JsonProperty("unitCurrency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UnitCurrency { get; set; }
    
        /// <summary>Gets or Sets TargetCurrency - ISO 4217 Alpha 3 currency code</summary>
        [Newtonsoft.Json.JsonProperty("targetCurrency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetCurrency { get; set; }
    
        /// <summary>Gets or Sets QuotationDate</summary>
        [Newtonsoft.Json.JsonProperty("quotationDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset QuotationDate { get; set; }
    
        /// <summary>Gets or Sets ContractIdentification</summary>
        [Newtonsoft.Json.JsonProperty("contractIdentification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContractIdentification { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ReportExchangeRate FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ReportExchangeRate>(data);
        }
    
    }
    
    /// <summary>Body of the JSON response for a successful read transaction list request. This account report contains transactions resulting from the query parameters.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransactionsResponse200Json 
    {
        /// <summary>Gets or Sets Account</summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountReference Account { get; set; }
    
        /// <summary>Gets or Sets Transactions</summary>
        [Newtonsoft.Json.JsonProperty("transactions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountReport Transactions { get; set; }
    
        /// <summary>Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance.</summary>
        [Newtonsoft.Json.JsonProperty("balances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Balance> Balances { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TransactionsResponse200Json FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TransactionsResponse200Json>(data);
        }
    
    }
    
    /// <summary>JSON based account report. This account report contains transactions resulting from the query parameters.  'booked' shall be contained if bookingStatus parameter is set to \"booked\" or \"both\".  'pending' is not contained if the bookingStatus parameter is set to \"booked\".</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AccountReport 
    {
        /// <summary>Gets or Sets Booked</summary>
        [Newtonsoft.Json.JsonProperty("booked", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionDetails> Booked { get; set; }
    
        /// <summary>Gets or Sets Pending</summary>
        [Newtonsoft.Json.JsonProperty("pending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionDetails> Pending { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; } = new System.Collections.Generic.Dictionary<string, HrefType>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AccountReport FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AccountReport>(data);
        }
    
    }
    
    /// <summary>A single balance element</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Balance 
    {
        /// <summary>Gets or Sets BalanceAmount</summary>
        [Newtonsoft.Json.JsonProperty("balanceAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount BalanceAmount { get; set; } = new Amount();
    
        /// <summary>Gets or Sets BalanceType</summary>
        [Newtonsoft.Json.JsonProperty("balanceType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BalanceType BalanceType { get; set; }
    
        /// <summary>This data element might be used to indicate e.g. with the expected or booked balance that no action is known  on the account, which is not yet booked.</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastChangeDateTime { get; set; }
    
        /// <summary>Reference date of the balance</summary>
        [Newtonsoft.Json.JsonProperty("referenceDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReferenceDate { get; set; }
    
        /// <summary>\"entryReference\" of the last commited transaction to support the TPP in identifying whether all  PSU transactions are already known.</summary>
        [Newtonsoft.Json.JsonProperty("lastCommittedTransaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastCommittedTransaction { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Balance FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Balance>(data);
        }
    
    }
    
    /// <summary>The ASPSP shall give at least one of the account reference identifiers:   - iban   - bban   - pan   - maskedPan   - msisdn If the account is a multicurrency account currency code in \"currency\" is set to \"XXX\".</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AccountDetails 
    {
        /// <summary>This shall be filled, if addressable resource are created by the ASPSP on the /accounts or /card-accounts endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }
    
        /// <summary>Gets or Sets Iban</summary>
        [Newtonsoft.Json.JsonProperty("iban", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iban { get; set; }
    
        /// <summary>Gets or Sets Bban</summary>
        [Newtonsoft.Json.JsonProperty("bban", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bban { get; set; }
    
        /// <summary>Gets or Sets Msisdn</summary>
        [Newtonsoft.Json.JsonProperty("msisdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Msisdn { get; set; }
    
        /// <summary>Gets or Sets Currency - ISO 4217 Alpha 3 currency code</summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }
    
        /// <summary>Name of the account given by the bank or the PSU in online-banking.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Product name of the bank for this account, proprietary definition.</summary>
        [Newtonsoft.Json.JsonProperty("product", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Product { get; set; }
    
        /// <summary>Gets or Sets CashAccountType - ExternalCashAccountType1Code from ISO 20022.</summary>
        [Newtonsoft.Json.JsonProperty("cashAccountType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CashAccountType { get; set; }
    
        /// <summary>Gets or Sets Status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountDetailsStatus? Status { get; set; }
    
        /// <summary>Gets or Sets Bic</summary>
        [Newtonsoft.Json.JsonProperty("bic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bic { get; set; }
    
        /// <summary>Case of a set of pending card transactions, the APSP will provide the relevant cash account the card is set up on.</summary>
        [Newtonsoft.Json.JsonProperty("linkedAccounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkedAccounts { get; set; }
    
        /// <summary>Specifies the usage of the account   * PRIV: private personal account   * ORGA: professional account</summary>
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountDetailsUsage? Usage { get; set; }
    
        /// <summary>Specifications that might be provided by the ASPSP   - characteristics of the account   - characteristics of the relevant card</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Details { get; set; }
    
        /// <summary>Gets or Sets Balances - A list of balances regarding this account, e.g. the current balance, the last booked balance. The list migght be restricted to the current ballance.</summary>
        [Newtonsoft.Json.JsonProperty("balances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Balance> Balances { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AccountDetails FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AccountDetails>(data);
        }
    
    }
    
    /// <summary>JSON Request body for the \"Confirmation of Funds Service\"  &lt;table&gt;  &lt;tr&gt;    &lt;td&gt;cardNumber&lt;/td&gt;    &lt;td&gt;String &lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;Card Number of the card issued by the PIISP. Should be delivered if available.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;account&lt;/td&gt;   &lt;td&gt; Account Reference&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;PSU's account number.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;payee&lt;/td&gt;   &lt;td&gt;Max70Text&lt;/td&gt;   &lt;td&gt;Optional&lt;/td&gt;   &lt;td&gt;The merchant where the card is accepted as an information to the PSU.&lt;/td&gt; &lt;/tr&gt;  &lt;tr&gt;   &lt;td&gt;instructedAmount&lt;/td&gt;   &lt;td&gt;Amount&lt;/td&gt;   &lt;td&gt;Mandatory&lt;/td&gt;   &lt;td&gt;Transaction amount to be checked within the funds check mechanism.&lt;/td&gt; &lt;/tr&gt;  &lt;/table&gt;</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfirmationOfFunds 
    {
        /// <summary>Card Number of the card issued by the PIISP.  Should be delivered if available.</summary>
        [Newtonsoft.Json.JsonProperty("cardNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CardNumber { get; set; }
    
        /// <summary>Gets or Sets Account</summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AccountReference Account { get; set; } = new AccountReference();
    
        /// <summary>Name payee</summary>
        [Newtonsoft.Json.JsonProperty("payee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payee { get; set; }
    
        /// <summary>Gets or Sets InstructedAmount</summary>
        [Newtonsoft.Json.JsonProperty("instructedAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount InstructedAmount { get; set; } = new Amount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ConfirmationOfFunds FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ConfirmationOfFunds>(data);
        }
    
    }
    
    /// <summary>Equals \"true\" if sufficient funds are available at the time of the request,  \"false\" otherwise.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfirmationOfFundsResponse200 
    {
        /// <summary>Gets or Sets FundsAvailable</summary>
        [Newtonsoft.Json.JsonProperty("fundsAvailable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FundsAvailable { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ConfirmationOfFundsResponse200 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ConfirmationOfFundsResponse200>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error401NGPIIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage401PIIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error401NGPIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage401PIIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401PIISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401PIISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage401PIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage401PIIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error403NGPIIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage403PIIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error403NGPIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage403PIIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403PIISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403PIISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage403PIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage403PIIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error404NGPIIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage404PIIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error404NGPIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage404PIIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404PIISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404PIISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage404PIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage404PIIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error405NGPIIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage405PIIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error405NGPIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage405PIIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PIISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PIISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage405PIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage405PIIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error409NGPIIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage409PIIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error409NGPIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage409PIIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409PIISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409PIISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage409PIIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage409PIIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Branch 
    {
        /// <summary>Organisation</summary>
        [Newtonsoft.Json.JsonProperty("organisation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Organisation Organisation { get; set; } = new Organisation();
    
        /// <summary>Name by which a party is known and which is usually used to identify that party</summary>
        [Newtonsoft.Json.JsonProperty("branchName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string BranchName { get; set; }
    
        /// <summary>Unique and unambiguous identification of a retail branch of a financial institution</summary>
        [Newtonsoft.Json.JsonProperty("branchIdentification", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string BranchIdentification { get; set; }
    
        /// <summary>Information on the type of branch</summary>
        [Newtonsoft.Json.JsonProperty("branchType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BranchType BranchType { get; set; }
    
        /// <summary>Postal Address</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Address Address { get; set; } = new Address();
    
        /// <summary>Description of the branch</summary>
        [Newtonsoft.Json.JsonProperty("branchDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(140, MinimumLength = 1)]
        public string BranchDescription { get; set; }
    
        /// <summary>Image related to the branch</summary>
        [Newtonsoft.Json.JsonProperty("branchPhoto", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BranchPhoto { get; set; }
    
        /// <summary>Collection of information that identifies a phone number, as defined by telecom services.</summary>
        [Newtonsoft.Json.JsonProperty("telephoneNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[+][0-9]{1,3}-[0-9()+-]{1,30}$")]
        public string TelephoneNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alternatePhone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AlternatePhone { get; set; }
    
        /// <summary>Collection of information that identifies a FAX number, as defined by telecom services.</summary>
        [Newtonsoft.Json.JsonProperty("faxNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> FaxNumber { get; set; }
    
        /// <summary>Geographic Coordinates</summary>
        [Newtonsoft.Json.JsonProperty("geographicLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GeographicLocation GeographicLocation { get; set; }
    
        /// <summary>Description on when the mobile branch is available. e.g. The weekend of Glastonbury festival; or Mondays and during the shrimp season also Wednesdays</summary>
        [Newtonsoft.Json.JsonProperty("daysOfTheWeek", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string DaysOfTheWeek { get; set; }
    
        /// <summary>Name of the stop of the mobile branch</summary>
        [Newtonsoft.Json.JsonProperty("stopName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(15, MinimumLength = 1)]
        public string StopName { get; set; }
    
        /// <summary>Time that the mobile branch is scheduled to arrive</summary>
        [Newtonsoft.Json.JsonProperty("arrivalTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string ArrivalTime { get; set; }
    
        /// <summary>Time that the mobile branch is scheduled to depart</summary>
        [Newtonsoft.Json.JsonProperty("departureTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string DepartureTime { get; set; }
    
        /// <summary>Place where the mobile branch is located, such as between the news agent and the church.</summary>
        [Newtonsoft.Json.JsonProperty("parkingLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string ParkingLocation { get; set; }
    
        /// <summary>Branch Opening Times</summary>
        [Newtonsoft.Json.JsonProperty("openingTimes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OpeningTimeInfo> OpeningTimes { get; set; } = new System.Collections.ObjectModel.Collection<OpeningTimeInfo>();
    
        [Newtonsoft.Json.JsonProperty("plannedBranchClosure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PlannedBranchClosure> PlannedBranchClosure { get; set; }
    
        /// <summary>Information about the accessibility</summary>
        [Newtonsoft.Json.JsonProperty("accessibilityTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BranchAccessibilityTypes? AccessibilityTypes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("branchSelfServeServiceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Anonymous> BranchSelfServeServiceName { get; set; }
    
        /// <summary>Self Services not described in BranchSelfServeServiceName</summary>
        [Newtonsoft.Json.JsonProperty("branchOtherSelfServices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> BranchOtherSelfServices { get; set; }
    
        /// <summary>Information about mediated branch facilities</summary>
        [Newtonsoft.Json.JsonProperty("branchMediatedServiceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Anonymous2> BranchMediatedServiceName { get; set; }
    
        /// <summary>Mediated Services not described in BranchMediatedServiceName</summary>
        [Newtonsoft.Json.JsonProperty("branchOtherMediatedServices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> BranchOtherMediatedServices { get; set; }
    
        /// <summary>Information about branch facilities</summary>
        [Newtonsoft.Json.JsonProperty("branchFacilitiesName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Anonymous3> BranchFacilitiesName { get; set; }
    
        /// <summary>Customer segment which the branch is able to service</summary>
        [Newtonsoft.Json.JsonProperty("customerSegment", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Anonymous4> CustomerSegment { get; set; } = new System.Collections.ObjectModel.Collection<Anonymous4>();
    
        /// <summary>Any other facilities not mentioned in BranchFacilitiesName</summary>
        [Newtonsoft.Json.JsonProperty("branchOtherFacilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> BranchOtherFacilities { get; set; }
    
        /// <summary>Indicated whether an ATM is at the branch</summary>
        [Newtonsoft.Json.JsonProperty("atmAtBranch", Required = Newtonsoft.Json.Required.Always)]
        public bool AtmAtBranch { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Branch FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Branch>(data);
        }
    
    }
    
    /// <summary>Organisation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Organisation 
    {
        /// <summary>Parent organisation</summary>
        [Newtonsoft.Json.JsonProperty("parentOrganisation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ParentOrganisation ParentOrganisation { get; set; } = new ParentOrganisation();
    
        /// <summary>Brand</summary>
        [Newtonsoft.Json.JsonProperty("brand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Brand Brand { get; set; } = new Brand();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Organisation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Organisation>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Address 
    {
        /// <summary>Gets or Sets Street</summary>
        [Newtonsoft.Json.JsonProperty("street", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Street { get; set; }
    
        /// <summary>Gets or Sets BuildingNumber</summary>
        [Newtonsoft.Json.JsonProperty("buildingNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BuildingNumber { get; set; }
    
        /// <summary>Gets or Sets City</summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string City { get; set; }
    
        /// <summary>Gets or Sets PostalCode</summary>
        [Newtonsoft.Json.JsonProperty("postalCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PostalCode { get; set; }
    
        /// <summary>Gets or Sets Country - ISO 3166 ALPHA2 country code</summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Country { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Address FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Address>(data);
        }
    
    }
    
    /// <summary>GeographicLocation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GeographicLocation 
    {
        /// <summary>The Latitude measured in decimal format according to ISO 213</summary>
        [Newtonsoft.Json.JsonProperty("latitude", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^-?\d{1,3}\.\d{1,8}$")]
        public string Latitude { get; set; }
    
        /// <summary>The longitude measured in decimal format according to ISO 213</summary>
        [Newtonsoft.Json.JsonProperty("longitude", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^-?\d{1,3}\.\d{1,8}$")]
        public string Longitude { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static GeographicLocation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GeographicLocation>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OpeningTimeInfo 
    {
        /// <summary>Day of the week</summary>
        [Newtonsoft.Json.JsonProperty("openingDay", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OpeningTimeInfoOpeningDay OpeningDay { get; set; }
    
        /// <summary>ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm</summary>
        [Newtonsoft.Json.JsonProperty("openingTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string OpeningTime { get; set; }
    
        /// <summary>ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm</summary>
        [Newtonsoft.Json.JsonProperty("closingTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string ClosingTime { get; set; }
    
        /// <summary>ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm</summary>
        [Newtonsoft.Json.JsonProperty("unavailableStartTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string UnavailableStartTime { get; set; }
    
        /// <summary>ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm</summary>
        [Newtonsoft.Json.JsonProperty("unavailableFinishTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$")]
        public string UnavailableFinishTime { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OpeningTimeInfo FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OpeningTimeInfo>(data);
        }
    
    }
    
    /// <summary>Planned branch closure</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PlannedBranchClosure 
    {
        /// <summary>Date when a branch is due to close temporarily or permanently</summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$")]
        public string StartDate { get; set; }
    
        /// <summary>Date when a branch is due to re-open following temporary closure</summary>
        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$")]
        public string EndDate { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static PlannedBranchClosure FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PlannedBranchClosure>(data);
        }
    
    }
    
    /// <summary>ParentOrganisation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParentOrganisation 
    {
        /// <summary>The LEI ID of the organisation</summary>
        [Newtonsoft.Json.JsonProperty("lei", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z0-9]{18,18}[0-9]{2,2}$")]
        public string Lei { get; set; }
    
        /// <summary>The BIC from the organisation</summary>
        [Newtonsoft.Json.JsonProperty("bic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?")]
        public string Bic { get; set; }
    
        /// <summary>Organisation Name</summary>
        [Newtonsoft.Json.JsonProperty("organisationName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OrganisationName OrganisationName { get; set; } = new OrganisationName();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ParentOrganisation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ParentOrganisation>(data);
        }
    
    }
    
    /// <summary>Brand Info</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Brand 
    {
        /// <summary>The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights 
        /// including patents, designs, trademarks and copyright. (Code: UK or EU only)</summary>
        [Newtonsoft.Json.JsonProperty("trademarkIPOCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BrandTrademarkIPOCode TrademarkIPOCode { get; set; }
    
        /// <summary>The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted</summary>
        [Newtonsoft.Json.JsonProperty("trademarkID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TrademarkID { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Brand FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Brand>(data);
        }
    
    }
    
    /// <summary>OrganisationName</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OrganisationName 
    {
        /// <summary>Legal Name of the organisation</summary>
        [Newtonsoft.Json.JsonProperty("legalName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string LegalName { get; set; }
    
        /// <summary>Distinctive Title of the organisation</summary>
        [Newtonsoft.Json.JsonProperty("distinctiveTitle", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string DistinctiveTitle { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OrganisationName FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OrganisationName>(data);
        }
    
    }
    
    /// <summary>ATM</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ATM 
    {
        /// <summary>Organisation</summary>
        [Newtonsoft.Json.JsonProperty("organisation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Organisation Organisation { get; set; } = new Organisation();
    
        /// <summary>Unique and unambiguous identification of a retail branch of a financial institution</summary>
        [Newtonsoft.Json.JsonProperty("branchIdentification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string BranchIdentification { get; set; }
    
        /// <summary>ATM terminal device identification for the acquirer and the issuer</summary>
        [Newtonsoft.Json.JsonProperty("atmid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Atmid { get; set; }
    
        /// <summary>Indicates the environment of the ATM</summary>
        [Newtonsoft.Json.JsonProperty("locationCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ATMLocationCategory? LocationCategory { get; set; }
    
        /// <summary>Site identifying code, where ATM is located</summary>
        [Newtonsoft.Json.JsonProperty("siteID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string SiteID { get; set; }
    
        /// <summary>Site identifying name, where ATM is located</summary>
        [Newtonsoft.Json.JsonProperty("siteName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string SiteName { get; set; }
    
        /// <summary>Postal Address</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Address Address { get; set; } = new Address();
    
        /// <summary>Geographic Coordinates</summary>
        [Newtonsoft.Json.JsonProperty("geographicLocation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GeographicLocation GeographicLocation { get; set; } = new GeographicLocation();
    
        /// <summary>Information about the accessibility</summary>
        [Newtonsoft.Json.JsonProperty("accessibilityTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Anonymous5> AccessibilityTypes { get; set; }
    
        /// <summary>Languages that the ATM supports</summary>
        [Newtonsoft.Json.JsonProperty("supportedLanguages", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> SupportedLanguages { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Information about ATM services</summary>
        [Newtonsoft.Json.JsonProperty("atmServices", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Anonymous6> AtmServices { get; set; } = new System.Collections.ObjectModel.Collection<Anonymous6>();
    
        /// <summary>ATM Service Description</summary>
        [Newtonsoft.Json.JsonProperty("additionalATMServices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AdditionalATMServices { get; set; }
    
        /// <summary>Defines currency type available for dispense</summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Currency { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Minimum currency denominations usually available</summary>
        [Newtonsoft.Json.JsonProperty("minimumValueDispensed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ATMMinimumValueDispensed? MinimumValueDispensed { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ATM FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ATM>(data);
        }
    
    }
    
    /// <summary>Body of the response for a successful cancel payment request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PaymentInitiationCancelResponse202 
    {
        /// <summary>Gets or Sets TransactionStatus</summary>
        [Newtonsoft.Json.JsonProperty("transactionStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentInitiationCancelResponse202TransactionStatus TransactionStatus { get; set; }
    
        /// <summary>Gets or Sets ScaMethods</summary>
        [Newtonsoft.Json.JsonProperty("scaMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AuthenticationObject> ScaMethods { get; set; }
    
        /// <summary>Gets or Sets ChosenScaMethod</summary>
        [Newtonsoft.Json.JsonProperty("chosenScaMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ChosenScaMethod { get; set; }
    
        /// <summary>Gets or Sets ChallengeData</summary>
        [Newtonsoft.Json.JsonProperty("challengeData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ChallengeData ChallengeData { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static PaymentInitiationCancelResponse202 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PaymentInitiationCancelResponse202>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 400.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error400NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage400PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error400NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error400NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage400PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage400PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage400PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage400PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage400PIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error401NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage401PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error401NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error401NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage401PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage401PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage401PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage401PIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 403.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error403NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage403PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error403NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error403NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage403PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage403PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage403PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage403PIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 404.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error404NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage404PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error404NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error404NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage404PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage404PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage404PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage404PIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error405NGPISCANC 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage405PISCANC> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error405NGPISCANC FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPISCANC>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage405PISCANC 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PISCANCCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PISCANCCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage405PISCANC FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage405PISCANC>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 409.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error409NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage409PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error409NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error409NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage409PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage409PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage409PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage409PIS>(data);
        }
    
    }
    
    /// <summary>NextGenPSD2 specific definition of reporting error information in case of a HTTP error code 401.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error405NGPIS 
    {
        /// <summary>Gets or Sets TppMessages</summary>
        [Newtonsoft.Json.JsonProperty("tppMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TppMessage405PIS> TppMessages { get; set; }
    
        /// <summary>Gets or Sets Links</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HrefType> _links { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Error405NGPIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error405NGPIS>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TppMessage405PIS 
    {
        /// <summary>Gets or Sets Category</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PISCategory Category { get; set; }
    
        /// <summary>Gets or Sets Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TppMessage405PISCode Code { get; set; }
    
        /// <summary>Gets or Sets Path</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Gets or Sets Text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Text { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TppMessage405PIS FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TppMessage405PIS>(data);
        }
    
    }
    
    /// <summary>Body of the response for a successful payment initiation status request in case of an JSON based endpoint.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PaymentInitiationStatusResponse200Json 
    {
        /// <summary>Gets or Sets TransactionStatus</summary>
        [Newtonsoft.Json.JsonProperty("transactionStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentInitiationStatusResponse200JsonTransactionStatus TransactionStatus { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static PaymentInitiationStatusResponse200Json FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PaymentInitiationStatusResponse200Json>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage400AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage400AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FORMATERROREnum")]
        FORMATERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARAMETERNOTCONSISTENTEnum")]
        PARAMETERNOTCONSISTENTEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARAMETERNOTSUPPORTEDEnum")]
        PARAMETERNOTSUPPORTEDEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEINVALIDEnum")]
        SERVICEINVALIDEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXPIREDEnum")]
        RESOURCEEXPIREDEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEBLOCKEDEnum")]
        RESOURCEBLOCKEDEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMESTAMPINVALIDEnum")]
        TIMESTAMPINVALIDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERIODINVALIDEnum")]
        PERIODINVALIDEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCAMETHODUNKNOWNEnum")]
        SCAMETHODUNKNOWNEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTUNKNOWNEnum")]
        CONSENTUNKNOWNEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SESSIONSNOTSUPPORTEDEnum")]
        SESSIONSNOTSUPPORTEDEnum = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEINVALIDEnum")]
        CERTIFICATEINVALIDEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEEXPIREDEnum")]
        CERTIFICATEEXPIREDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEBLOCKEDEnum")]
        CERTIFICATEBLOCKEDEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEREVOKEEnum")]
        CERTIFICATEREVOKEEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEMISSINGEnum")]
        CERTIFICATEMISSINGEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREINVALIDEnum")]
        SIGNATUREINVALIDEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREMISSINGEnum")]
        SIGNATUREMISSINGEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CORPORATEIDINVALIDEnum")]
        CORPORATEIDINVALIDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PSUCREDENTIALSINVALIDEnum")]
        PSUCREDENTIALSINVALIDEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTINVALIDEnum")]
        CONSENTINVALIDEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTEXPIREDEnum")]
        CONSENTEXPIREDEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENUNKNOWNEnum")]
        TOKENUNKNOWNEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENINVALIDEnum")]
        TOKENINVALIDEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENEXPIREDEnum")]
        TOKENEXPIREDEnum = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTUNKNOWNEnum")]
        CONSENTUNKNOWNEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEBLOCKEDEnum")]
        SERVICEBLOCKEDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXPIREDEnum")]
        RESOURCEEXPIREDEnum = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWNEnum")]
        UNKNOWNEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage406AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage406AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage429AISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage429AISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EXCEEDEDEnum")]
        EXCEEDEDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum StartScaprocessResponseScaStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ReceivedEnum")]
        ReceivedEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PsuIdentifiedEnum")]
        PsuIdentifiedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PsuAuthenticatedEnum")]
        PsuAuthenticatedEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ScaMethodSelectedEnum")]
        ScaMethodSelectedEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StartedEnum")]
        StartedEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FinalisedEnum")]
        FinalisedEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FailedEnum")]
        FailedEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ExemptedEnum")]
        ExemptedEnum = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AuthenticationObjectAuthenticationType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SMSOTPEnum")]
        SMSOTPEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CHIPOTPEnum")]
        CHIPOTPEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PHOTOOTPEnum")]
        PHOTOOTPEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUSHOTPEnum")]
        PUSHOTPEnum = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ChallengeDataOtpFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CHARACTERS")]
        CHARACTERS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTEGER")]
        INTEGER = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConsentInformationResponse200JsonConsentStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ReceivedEnum")]
        ReceivedEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RejectedEnum")]
        RejectedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ValidEnum")]
        ValidEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RevokedByPsuEnum")]
        RevokedByPsuEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ExpiredEnum")]
        ExpiredEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TerminatedByTppEnum")]
        TerminatedByTppEnum = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AccountAccessAvailableAccounts
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLACCOUNTS")]
        ALLACCOUNTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALLACCOUNTSWITHBALANCES")]
        ALLACCOUNTSWITHBALANCES = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AccountAccessAllPsd2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLACCOUNTS")]
        ALLACCOUNTS = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ScaStatusResponseScaStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ReceivedEnum")]
        ReceivedEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PsuIdentifiedEnum")]
        PsuIdentifiedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PsuAuthenticatedEnum")]
        PsuAuthenticatedEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ScaMethodSelectedEnum")]
        ScaMethodSelectedEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StartedEnum")]
        StartedEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FinalisedEnum")]
        FinalisedEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FailedEnum")]
        FailedEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ExemptedEnum")]
        ExemptedEnum = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConsentStatusResponse200ConsentStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ReceivedEnum")]
        ReceivedEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RejectedEnum")]
        RejectedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ValidEnum")]
        ValidEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RevokedByPsuEnum")]
        RevokedByPsuEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ExpiredEnum")]
        ExpiredEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TerminatedByTppEnum")]
        TerminatedByTppEnum = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TransactionDetailsPurposeCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BKDFEnum")]
        BKDFEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BKFEEnum")]
        BKFEEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BKFMEnum")]
        BKFMEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BKIPEnum")]
        BKIPEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BKPPEnum")]
        BKPPEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBLKEnum")]
        CBLKEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDCBEnum")]
        CDCBEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDCDEnum")]
        CDCDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDCSEnum")]
        CDCSEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDDPEnum")]
        CDDPEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDOCEnum")]
        CDOCEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDQCEnum")]
        CDQCEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ETUPEnum")]
        ETUPEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FCOLEnum")]
        FCOLEnum = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MTUPEnum")]
        MTUPEnum = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCTEnum")]
        ACCTEnum = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CASHEnum")]
        CASHEnum = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COLLEnum")]
        COLLEnum = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CSDBEnum")]
        CSDBEnum = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEPTEnum")]
        DEPTEnum = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTCEnum")]
        INTCEnum = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LIMAEnum")]
        LIMAEnum = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETTEnum")]
        NETTEnum = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BFWDEnum")]
        BFWDEnum = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCIREnum")]
        CCIREnum = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCPCEnum")]
        CCPCEnum = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCPMEnum")]
        CCPMEnum = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCSMEnum")]
        CCSMEnum = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRDSEnum")]
        CRDSEnum = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRPREnum")]
        CRPREnum = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRSPEnum")]
        CRSPEnum = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRTLEnum")]
        CRTLEnum = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQPTEnum")]
        EQPTEnum = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUSEnum")]
        EQUSEnum = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPTEnum")]
        EXPTEnum = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXTDEnum")]
        EXTDEnum = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FIXIEnum")]
        FIXIEnum = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FWBCEnum")]
        FWBCEnum = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FWCCEnum")]
        FWCCEnum = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FWSBEnum")]
        FWSBEnum = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FWSCEnum")]
        FWSCEnum = 40,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MARGEnum")]
        MARGEnum = 41,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MBSBEnum")]
        MBSBEnum = 42,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MBSCEnum")]
        MBSCEnum = 43,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MGCCEnum")]
        MGCCEnum = 44,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MGSCEnum")]
        MGSCEnum = 45,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OCCCEnum")]
        OCCCEnum = 46,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPBCEnum")]
        OPBCEnum = 47,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPCCEnum")]
        OPCCEnum = 48,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPSBEnum")]
        OPSBEnum = 49,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPSCEnum")]
        OPSCEnum = 50,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPTNEnum")]
        OPTNEnum = 51,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OTCDEnum")]
        OTCDEnum = 52,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPOEnum")]
        REPOEnum = 53,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RPBCEnum")]
        RPBCEnum = 54,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RPCCEnum")]
        RPCCEnum = 55,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RPSBEnum")]
        RPSBEnum = 56,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RPSCEnum")]
        RPSCEnum = 57,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RVPOEnum")]
        RVPOEnum = 58,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SBSCEnum")]
        SBSCEnum = 59,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCIEEnum")]
        SCIEEnum = 60,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCIREnum")]
        SCIREnum = 61,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCRPEnum")]
        SCRPEnum = 62,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHBCEnum")]
        SHBCEnum = 63,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHCCEnum")]
        SHCCEnum = 64,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHSLEnum")]
        SHSLEnum = 65,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLEBEnum")]
        SLEBEnum = 66,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLOAEnum")]
        SLOAEnum = 67,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWBCEnum")]
        SWBCEnum = 68,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWCCEnum")]
        SWCCEnum = 69,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWPTEnum")]
        SWPTEnum = 70,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWSBEnum")]
        SWSBEnum = 71,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWSCEnum")]
        SWSCEnum = 72,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TBASEnum")]
        TBASEnum = 73,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TBBCEnum")]
        TBBCEnum = 74,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TBCCEnum")]
        TBCCEnum = 75,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRCPEnum")]
        TRCPEnum = 76,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AGRTEnum")]
        AGRTEnum = 77,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARENEnum")]
        ARENEnum = 78,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BEXPEnum")]
        BEXPEnum = 79,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOCEEnum")]
        BOCEEnum = 80,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMCEnum")]
        COMCEnum = 81,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CPYREnum")]
        CPYREnum = 82,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GDDSEnum")]
        GDDSEnum = 83,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GDSVEnum")]
        GDSVEnum = 84,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GSCBEnum")]
        GSCBEnum = 85,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LICFEnum")]
        LICFEnum = 86,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MP2BEnum")]
        MP2BEnum = 87,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POPEEnum")]
        POPEEnum = 88,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROYAEnum")]
        ROYAEnum = 89,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCVEEnum")]
        SCVEEnum = 90,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVEnum")]
        SERVEnum = 91,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUBSEnum")]
        SUBSEnum = 92,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUPPEnum")]
        SUPPEnum = 93,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRADEnum")]
        TRADEnum = 94,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CHAREnum")]
        CHAREnum = 95,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMTEnum")]
        COMTEnum = 96,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MP2PEnum")]
        MP2PEnum = 97,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ECPGEnum")]
        ECPGEnum = 98,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ECPREnum")]
        ECPREnum = 99,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ECPUEnum")]
        ECPUEnum = 100,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EPAYEnum")]
        EPAYEnum = 101,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLPREnum")]
        CLPREnum = 102,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMPEnum")]
        COMPEnum = 103,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DBTCEnum")]
        DBTCEnum = 104,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOVIEnum")]
        GOVIEnum = 105,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HLRPEnum")]
        HLRPEnum = 106,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HLSTEnum")]
        HLSTEnum = 107,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INPCEnum")]
        INPCEnum = 108,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INPREnum")]
        INPREnum = 109,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSCEnum")]
        INSCEnum = 110,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSUEnum")]
        INSUEnum = 111,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTEEnum")]
        INTEEnum = 112,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LBRIEnum")]
        LBRIEnum = 113,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LIFIEnum")]
        LIFIEnum = 114,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOANEnum")]
        LOANEnum = 115,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOAREnum")]
        LOAREnum = 116,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PENOEnum")]
        PENOEnum = 117,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PPTIEnum")]
        PPTIEnum = 118,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RELGEnum")]
        RELGEnum = 119,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RINPEnum")]
        RINPEnum = 120,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRFDEnum")]
        TRFDEnum = 121,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FORWEnum")]
        FORWEnum = 122,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FXNTEnum")]
        FXNTEnum = 123,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ADMGEnum")]
        ADMGEnum = 124,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ADVAEnum")]
        ADVAEnum = 125,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BCDMEnum")]
        BCDMEnum = 126,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BCFGEnum")]
        BCFGEnum = 127,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLDMEnum")]
        BLDMEnum = 128,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BNETEnum")]
        BNETEnum = 129,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBFFEnum")]
        CBFFEnum = 130,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBFREnum")]
        CBFREnum = 131,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCRDEnum")]
        CCRDEnum = 132,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDBLEnum")]
        CDBLEnum = 133,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CFEEEnum")]
        CFEEEnum = 134,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CGDDEnum")]
        CGDDEnum = 135,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CORTEnum")]
        CORTEnum = 136,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COSTEnum")]
        COSTEnum = 137,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CPKCEnum")]
        CPKCEnum = 138,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DCRDEnum")]
        DCRDEnum = 139,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DSMTEnum")]
        DSMTEnum = 140,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DVPMEnum")]
        DVPMEnum = 141,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDUCEnum")]
        EDUCEnum = 142,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FACTEnum")]
        FACTEnum = 143,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FANDEnum")]
        FANDEnum = 144,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FCPMEnum")]
        FCPMEnum = 145,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FEESEnum")]
        FEESEnum = 146,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOVTEnum")]
        GOVTEnum = 147,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICCPEnum")]
        ICCPEnum = 148,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDCPEnum")]
        IDCPEnum = 149,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IHRPEnum")]
        IHRPEnum = 150,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSMEnum")]
        INSMEnum = 151,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IVPTEnum")]
        IVPTEnum = 152,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MCDMEnum")]
        MCDMEnum = 153,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MCFGEnum")]
        MCFGEnum = 154,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MSVCEnum")]
        MSVCEnum = 155,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOWSEnum")]
        NOWSEnum = 156,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OCDMEnum")]
        OCDMEnum = 157,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OCFGEnum")]
        OCFGEnum = 158,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OFEEEnum")]
        OFEEEnum = 159,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OTHREnum")]
        OTHREnum = 160,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADDEnum")]
        PADDEnum = 161,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PTSPEnum")]
        PTSPEnum = 162,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RCKEEnum")]
        RCKEEnum = 163,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RCPTEnum")]
        RCPTEnum = 164,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REBTEnum")]
        REBTEnum = 165,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REFUEnum")]
        REFUEnum = 166,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RENTEnum")]
        RENTEnum = 167,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REODEnum")]
        REODEnum = 168,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RIMBEnum")]
        RIMBEnum = 169,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RPNTEnum")]
        RPNTEnum = 170,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RRBNEnum")]
        RRBNEnum = 171,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RVPMEnum")]
        RVPMEnum = 172,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLPIEnum")]
        SLPIEnum = 173,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPLTEnum")]
        SPLTEnum = 174,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STDYEnum")]
        STDYEnum = 175,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TBANEnum")]
        TBANEnum = 176,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TBILEnum")]
        TBILEnum = 177,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TCSCEnum")]
        TCSCEnum = 178,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TELIEnum")]
        TELIEnum = 179,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TMPGEnum")]
        TMPGEnum = 180,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TPRIEnum")]
        TPRIEnum = 181,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TPRPEnum")]
        TPRPEnum = 182,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRNCEnum")]
        TRNCEnum = 183,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRVCEnum")]
        TRVCEnum = 184,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WEBIEnum")]
        WEBIEnum = 185,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANNIEnum")]
        ANNIEnum = 186,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAFIEnum")]
        CAFIEnum = 187,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CFDIEnum")]
        CFDIEnum = 188,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CMDTEnum")]
        CMDTEnum = 189,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DERIEnum")]
        DERIEnum = 190,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DIVDEnum")]
        DIVDEnum = 191,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FREXEnum")]
        FREXEnum = 192,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEDGEnum")]
        HEDGEnum = 193,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVSEnum")]
        INVSEnum = 194,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRMEEnum")]
        PRMEEnum = 195,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SAVGEnum")]
        SAVGEnum = 196,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SECUEnum")]
        SECUEnum = 197,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SEPIEnum")]
        SEPIEnum = 198,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TREAEnum")]
        TREAEnum = 199,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNITEnum")]
        UNITEnum = 200,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FNETEnum")]
        FNETEnum = 201,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FUTREnum")]
        FUTREnum = 202,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANTSEnum")]
        ANTSEnum = 203,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CVCFEnum")]
        CVCFEnum = 204,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DMEQEnum")]
        DMEQEnum = 205,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNTSEnum")]
        DNTSEnum = 206,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HLTCEnum")]
        HLTCEnum = 207,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HLTIEnum")]
        HLTIEnum = 208,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HSPCEnum")]
        HSPCEnum = 209,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICRFEnum")]
        ICRFEnum = 210,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LTCFEnum")]
        LTCFEnum = 211,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MAFCEnum")]
        MAFCEnum = 212,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MARFEnum")]
        MARFEnum = 213,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MDCSEnum")]
        MDCSEnum = 214,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VIEWEnum")]
        VIEWEnum = 215,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CDEPEnum")]
        CDEPEnum = 216,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWFPEnum")]
        SWFPEnum = 217,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWPPEnum")]
        SWPPEnum = 218,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWRSEnum")]
        SWRSEnum = 219,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SWUFEnum")]
        SWUFEnum = 220,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ADCSEnum")]
        ADCSEnum = 221,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AEMPEnum")]
        AEMPEnum = 222,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALLWEnum")]
        ALLWEnum = 223,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALMYEnum")]
        ALMYEnum = 224,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BBSCEnum")]
        BBSCEnum = 225,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BECHEnum")]
        BECHEnum = 226,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BENEEnum")]
        BENEEnum = 227,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BONUEnum")]
        BONUEnum = 228,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCHDEnum")]
        CCHDEnum = 229,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMMEnum")]
        COMMEnum = 230,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CSLPEnum")]
        CSLPEnum = 231,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GFRPEnum")]
        GFRPEnum = 232,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GVEAEnum")]
        GVEAEnum = 233,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GVEBEnum")]
        GVEBEnum = 234,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GVECEnum")]
        GVECEnum = 235,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GVEDEnum")]
        GVEDEnum = 236,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GWLTEnum")]
        GWLTEnum = 237,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HRECEnum")]
        HRECEnum = 238,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYREnum")]
        PAYREnum = 239,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PEFCEnum")]
        PEFCEnum = 240,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PENSEnum")]
        PENSEnum = 241,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRCPEnum")]
        PRCPEnum = 242,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHBSEnum")]
        RHBSEnum = 243,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SALAEnum")]
        SALAEnum = 244,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSBEEnum")]
        SSBEEnum = 245,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LBINEnum")]
        LBINEnum = 246,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LCOLEnum")]
        LCOLEnum = 247,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LFEEEnum")]
        LFEEEnum = 248,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LMEQEnum")]
        LMEQEnum = 249,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LMFIEnum")]
        LMFIEnum = 250,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LMRKEnum")]
        LMRKEnum = 251,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LREBEnum")]
        LREBEnum = 252,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LREVEnum")]
        LREVEnum = 253,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LSFLEnum")]
        LSFLEnum = 254,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ESTXEnum")]
        ESTXEnum = 255,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FWLVEnum")]
        FWLVEnum = 256,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GSTXEnum")]
        GSTXEnum = 257,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HSTXEnum")]
        HSTXEnum = 258,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTXEnum")]
        INTXEnum = 259,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NITXEnum")]
        NITXEnum = 260,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PTXPEnum")]
        PTXPEnum = 261,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RDTXEnum")]
        RDTXEnum = 262,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TAXSEnum")]
        TAXSEnum = 263,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VATXEnum")]
        VATXEnum = 264,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WHLDEnum")]
        WHLDEnum = 265,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TAXREnum")]
        TAXREnum = 266,
    
        [System.Runtime.Serialization.EnumMember(Value = @"B112Enum")]
        B112Enum = 267,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BR12Enum")]
        BR12Enum = 268,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLRFEnum")]
        TLRFEnum = 269,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLRREnum")]
        TLRREnum = 270,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AIRBEnum")]
        AIRBEnum = 271,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BUSBEnum")]
        BUSBEnum = 272,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FERBEnum")]
        FERBEnum = 273,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RLWYEnum")]
        RLWYEnum = 274,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRPTEnum")]
        TRPTEnum = 275,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBTVEnum")]
        CBTVEnum = 276,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ELECEnum")]
        ELECEnum = 277,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENRGEnum")]
        ENRGEnum = 278,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GASBEnum")]
        GASBEnum = 279,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NWCHEnum")]
        NWCHEnum = 280,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NWCMEnum")]
        NWCMEnum = 281,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OTLCEnum")]
        OTLCEnum = 282,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PHONEnum")]
        PHONEnum = 283,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBILEnum")]
        UBILEnum = 284,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WTEREnum")]
        WTEREnum = 285,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BalanceType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ClosingBookedEnum")]
        ClosingBookedEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ExpectedEnum")]
        ExpectedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AuthorisedEnum")]
        AuthorisedEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OpeningBookedEnum")]
        OpeningBookedEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"InterimAvailableEnum")]
        InterimAvailableEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"InterimBookedEnum")]
        InterimBookedEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ForwardAvailableEnum")]
        ForwardAvailableEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NonInvoicedEnum")]
        NonInvoicedEnum = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AccountDetailsStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EnabledEnum")]
        EnabledEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DeletedEnum")]
        DeletedEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BlockedEnum")]
        BlockedEnum = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AccountDetailsUsage
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRIV")]
        PRIV = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORGA")]
        ORGA = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401PIISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401PIISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEINVALIDEnum")]
        CERTIFICATEINVALIDEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEEXPIREDEnum")]
        CERTIFICATEEXPIREDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEBLOCKEDEnum")]
        CERTIFICATEBLOCKEDEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEREVOKEEnum")]
        CERTIFICATEREVOKEEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEMISSINGEnum")]
        CERTIFICATEMISSINGEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREINVALIDEnum")]
        SIGNATUREINVALIDEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREMISSINGEnum")]
        SIGNATUREMISSINGEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CORPORATEIDINVALIDEnum")]
        CORPORATEIDINVALIDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PSUCREDENTIALSINVALIDEnum")]
        PSUCREDENTIALSINVALIDEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTINVALIDEnum")]
        CONSENTINVALIDEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTEXPIREDEnum")]
        CONSENTEXPIREDEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENUNKNOWNEnum")]
        TOKENUNKNOWNEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENINVALIDEnum")]
        TOKENINVALIDEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENEXPIREDEnum")]
        TOKENEXPIREDEnum = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403PIISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403PIISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTUNKNOWNEnum")]
        CONSENTUNKNOWNEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEBLOCKEDEnum")]
        SERVICEBLOCKEDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXPIREDEnum")]
        RESOURCEEXPIREDEnum = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404PIISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404PIISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWNEnum")]
        UNKNOWNEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PIISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PIISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409PIISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409PIISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BranchType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"physical")]
        Physical = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"mobile")]
        Mobile = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BranchAccessibilityTypes
    {
        [System.Runtime.Serialization.EnumMember(Value = @"audioCashMachine")]
        AudioCashMachine = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"automaticDoors")]
        AutomaticDoors = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"chairAccess")]
        ChairAccess = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"driveThru")]
        DriveThru = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"externalRamp")]
        ExternalRamp = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"inductionLoop")]
        InductionLoop = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internalRamp")]
        InternalRamp = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"levelAccess")]
        LevelAccess = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"lowerLevelCounter")]
        LowerLevelCounter = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wheelchairAccess")]
        WheelchairAccess = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous
    {
        [System.Runtime.Serialization.EnumMember(Value = @"accountVerificationService")]
        AccountVerificationService = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"assistedServiceCounter")]
        AssistedServiceCounter = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"businessDepositTerminal")]
        BusinessDepositTerminal = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cashChequeDepositMachineCoin")]
        CashChequeDepositMachineCoin = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cashChequeDepositMachineNoCoin")]
        CashChequeDepositMachineNoCoin = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"externalAtmAudio")]
        ExternalAtmAudio = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"externalAtmNoAudio")]
        ExternalAtmNoAudio = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"externalQuickServicePoint")]
        ExternalQuickServicePoint = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internalAtmAudio")]
        InternalAtmAudio = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internalAtmNoAudio")]
        InternalAtmNoAudio = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internalQuickServicePoint")]
        InternalQuickServicePoint = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"lodgementDevice")]
        LodgementDevice = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"onlineBankingPoint")]
        OnlineBankingPoint = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"quickDeposit")]
        QuickDeposit = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"saturdayCounterService")]
        SaturdayCounterService = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"selfServiceAccountOpening")]
        SelfServiceAccountOpening = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"statementPrinter")]
        StatementPrinter = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"bureauDeChange")]
        BureauDeChange = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"businessCounter")]
        BusinessCounter = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cardIssuanceFacility")]
        CardIssuanceFacility = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"counterServices")]
        CounterServices = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"driveThru")]
        DriveThru = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"mortgageAdvisor")]
        MortgageAdvisor = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"nightSafe")]
        NightSafe = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"onDemandCurrency")]
        OnDemandCurrency = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"premierCounter")]
        PremierCounter = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"videoBanking")]
        VideoBanking = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wheelChairAccess")]
        WheelChairAccess = 10,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"businessITSupport")]
        BusinessITSupport = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"collectionLockers")]
        CollectionLockers = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"meetingRooms")]
        MeetingRooms = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"parking")]
        Parking = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wifi")]
        Wifi = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"business")]
        Business = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"corporate")]
        Corporate = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"personal")]
        Personal = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"premier")]
        Premier = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"private")]
        Private = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"select")]
        Select = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"sME")]
        SME = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wealth")]
        Wealth = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OpeningTimeInfoOpeningDay
    {
        [System.Runtime.Serialization.EnumMember(Value = @"monday")]
        Monday = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"tuesday")]
        Tuesday = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wednesday")]
        Wednesday = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"thursday")]
        Thursday = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"friday")]
        Friday = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"saturday")]
        Saturday = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"sunday")]
        Sunday = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"public_and_Bank_Holiday")]
        Public_and_Bank_Holiday = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BrandTrademarkIPOCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"uK")]
        UK = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"eU")]
        EU = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ATMLocationCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"airport")]
        Airport = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"bankSpecialisedOutlet")]
        BankSpecialisedOutlet = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"branchExternal")]
        BranchExternal = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"branchInternal")]
        BranchInternal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"branchLobby")]
        BranchLobby = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"bureauDeChange")]
        BureauDeChange = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"coachStation")]
        CoachStation = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"commercialSpaceInternal")]
        CommercialSpaceInternal = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"convenienceStore")]
        ConvenienceStore = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"exhibitionCentre")]
        ExhibitionCentre = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"factoryOrOffice")]
        FactoryOrOffice = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"fillingStation")]
        FillingStation = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"financialInstitution")]
        FinancialInstitution = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"governmentOffice")]
        GovernmentOffice = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"hospital")]
        Hospital = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"hotel")]
        Hotel = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"kioskPod")]
        KioskPod = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"leisureCentre")]
        LeisureCentre = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"pleasurePark")]
        PleasurePark = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"publicHouse")]
        PublicHouse = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"railwayStation")]
        RailwayStation = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remoteUnit")]
        RemoteUnit = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"retailerDepartmentStore")]
        RetailerDepartmentStore = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"retailerOutlet")]
        RetailerOutlet = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"seaportTerminal")]
        SeaportTerminal = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"serviceStation")]
        ServiceStation = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"shoppingCentreExternal")]
        ShoppingCentreExternal = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"shoppingCentreInternal")]
        ShoppingCentreInternal = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"storageDepot")]
        StorageDepot = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"supermarketExternal")]
        SupermarketExternal = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"supermarketInternal")]
        SupermarketInternal = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"undergroundRailwayStation")]
        UndergroundRailwayStation = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"universityOrCollege")]
        UniversityOrCollege = 32,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"audioCashMachine")]
        AudioCashMachine = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"automaticDoors")]
        AutomaticDoors = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"chairAccess")]
        ChairAccess = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"driveThru")]
        DriveThru = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"externalRamp")]
        ExternalRamp = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"inductionLoop")]
        InductionLoop = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internalRamp")]
        InternalRamp = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"levelAccess")]
        LevelAccess = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"lowerLevelCounter")]
        LowerLevelCounter = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"wheelchairAccess")]
        WheelchairAccess = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"balance")]
        Balance = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"billPayments")]
        BillPayments = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cashDeposits")]
        CashDeposits = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cashWithdrawal")]
        CashWithdrawal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"charityDonation")]
        CharityDonation = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"chequeBookRequest")]
        ChequeBookRequest = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"chequeDeposits")]
        ChequeDeposits = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"fastCash")]
        FastCash = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"miniStatement")]
        MiniStatement = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"mobileBankingRegistration")]
        MobileBankingRegistration = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"mobilePaymentRegistration")]
        MobilePaymentRegistration = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"mobilePhoneTopUp")]
        MobilePhoneTopUp = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orderStatement")]
        OrderStatement = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"pINActivation")]
        PINActivation = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"pINChange")]
        PINChange = 14,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ATMMinimumValueDispensed
    {
        [System.Runtime.Serialization.EnumMember(Value = @"μΙΝ_5")]
        ΜΙΝ_5 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"μΙΝ_10")]
        ΜΙΝ_10 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"μΙΝ_20")]
        ΜΙΝ_20 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"μΙΝ_50")]
        ΜΙΝ_50 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"μΙΝ_100")]
        ΜΙΝ_100 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PaymentInitiationCancelResponse202TransactionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACCCEnum")]
        ACCCEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCPEnum")]
        ACCPEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACSCEnum")]
        ACSCEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACSPEnum")]
        ACSPEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTCEnum")]
        ACTCEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACWCEnum")]
        ACWCEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACWPEnum")]
        ACWPEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RCVDEnum")]
        RCVDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PDNGEnum")]
        PDNGEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RJCTEnum")]
        RJCTEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCEnum")]
        CANCEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACFCEnum")]
        ACFCEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PATCEnum")]
        PATCEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTEnum")]
        PARTEnum = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage400PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage400PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FORMATERROREnum")]
        FORMATERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARAMETERNOTCONSISTENTEnum")]
        PARAMETERNOTCONSISTENTEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARAMETERNOTSUPPORTEDEnum")]
        PARAMETERNOTSUPPORTEDEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEINVALIDEnum")]
        SERVICEINVALIDEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXPIREDEnum")]
        RESOURCEEXPIREDEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEBLOCKEDEnum")]
        RESOURCEBLOCKEDEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMESTAMPINVALIDEnum")]
        TIMESTAMPINVALIDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERIODINVALIDEnum")]
        PERIODINVALIDEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCAMETHODUNKNOWNEnum")]
        SCAMETHODUNKNOWNEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTUNKNOWNEnum")]
        CONSENTUNKNOWNEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENTFAILEDEnum")]
        PAYMENTFAILEDEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXECUTIONDATEINVALIDEnum")]
        EXECUTIONDATEINVALIDEnum = 12,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage401PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEINVALIDEnum")]
        CERTIFICATEINVALIDEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEEXPIREDEnum")]
        CERTIFICATEEXPIREDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEBLOCKEDEnum")]
        CERTIFICATEBLOCKEDEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEREVOKEEnum")]
        CERTIFICATEREVOKEEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATEMISSINGEnum")]
        CERTIFICATEMISSINGEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREINVALIDEnum")]
        SIGNATUREINVALIDEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATUREMISSINGEnum")]
        SIGNATUREMISSINGEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CORPORATEIDINVALIDEnum")]
        CORPORATEIDINVALIDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PSUCREDENTIALSINVALIDEnum")]
        PSUCREDENTIALSINVALIDEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTINVALIDEnum")]
        CONSENTINVALIDEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTEXPIREDEnum")]
        CONSENTEXPIREDEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENUNKNOWNEnum")]
        TOKENUNKNOWNEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENINVALIDEnum")]
        TOKENINVALIDEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOKENEXPIREDEnum")]
        TOKENEXPIREDEnum = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REQUIREDKIDMISSINGEnum")]
        REQUIREDKIDMISSINGEnum = 14,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage403PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONSENTUNKNOWNEnum")]
        CONSENTUNKNOWNEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEBLOCKEDEnum")]
        SERVICEBLOCKEDEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXPIREDEnum")]
        RESOURCEEXPIREDEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRODUCTINVALIDEnum")]
        PRODUCTINVALIDEnum = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage404PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEUNKNOWNEnum")]
        RESOURCEUNKNOWNEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRODUCTUNKNOWNEnum")]
        PRODUCTUNKNOWNEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PISCANCCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PISCANCCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLATIONINVALIDEnum")]
        CANCELLATIONINVALIDEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICEINVALIDEnum")]
        SERVICEINVALIDEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage409PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PISCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROREnum")]
        ERROREnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNINGEnum")]
        WARNINGEnum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TppMessage405PISCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDEnum")]
        INVALIDEnum = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PaymentInitiationStatusResponse200JsonTransactionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACCCEnum")]
        ACCCEnum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCPEnum")]
        ACCPEnum = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACSCEnum")]
        ACSCEnum = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACSPEnum")]
        ACSPEnum = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTCEnum")]
        ACTCEnum = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACWCEnum")]
        ACWCEnum = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACWPEnum")]
        ACWPEnum = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RCVDEnum")]
        RCVDEnum = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PDNGEnum")]
        PDNGEnum = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RJCTEnum")]
        RJCTEnum = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCEnum")]
        CANCEnum = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACFCEnum")]
        ACFCEnum = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PATCEnum")]
        PATCEnum = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTEnum")]
        PARTEnum = 13,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class AppException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public AppException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class AppException<TResult> : AppException
    {
        public TResult Result { get; private set; }

        public AppException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

    #pragma warning restore
}